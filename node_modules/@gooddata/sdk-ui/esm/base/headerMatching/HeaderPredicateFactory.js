import { getMappingHeaderIdentifier, getMappingHeaderLocalIdentifier, getMappingHeaderUri, hasMappingHeaderLocalIdentifier, } from "./MappingHeader";
import { isMeasureDescriptor, isResultAttributeHeader } from "@gooddata/sdk-backend-spi";
import { attributeDisplayFormRef, attributeLocalId, isArithmeticMeasure, isAttribute, isIdentifierRef, isObjRef, isSimpleMeasure, measureArithmeticOperands, measureIdentifier, measureItem, measureLocalId, measureMasterIdentifier, measureUri, } from "@gooddata/sdk-model";
/**
 * This predicate is returned when predicate factory encounters invalid input. Having it to keep backward
 * compatibility with the previous more lenient behavior.
 */
var alwaysFalsePredicate = function () { return false; };
function arithmeticMeasureLocalIdentifierDeepMatch(dv, operandLocalIdentifier, predicate, context) {
    var operand = dv.def().measure(operandLocalIdentifier);
    var operandDescriptor = dv.meta().measureDescriptor(operandLocalIdentifier);
    if (isArithmeticMeasure(operand)) {
        var operands = measureArithmeticOperands(operand);
        return (operands ? operands : []).some(function (operandLocalIdentifier) {
            return arithmeticMeasureLocalIdentifierDeepMatch(dv, operandLocalIdentifier, predicate, context);
        });
    }
    return predicate(operandDescriptor, context);
}
function getMasterMeasureOperandIdentifiers(measure) {
    return measureArithmeticOperands(measure);
}
function getDerivedMeasureMasterMeasureOperandIdentifiers(measure, dv) {
    var masterMeasureLocalIdentifier = measureMasterIdentifier(measure);
    if (!masterMeasureLocalIdentifier) {
        return null;
    }
    var masterMeasure = dv.def().measure(masterMeasureLocalIdentifier);
    var result = getMasterMeasureOperandIdentifiers(masterMeasure);
    if (result === undefined) {
        return null;
    }
    return result;
}
function composedFromQualifier(predicate) {
    return function (header, context) {
        if (!isMeasureDescriptor(header)) {
            return false;
        }
        var dv = context.dv;
        var measureLocalIdentifier = getMappingHeaderLocalIdentifier(header);
        var measure = dv.def().measure(measureLocalIdentifier);
        if (!measure) {
            return false;
        }
        var arithmeticMeasureOperands = getDerivedMeasureMasterMeasureOperandIdentifiers(measure, dv) ||
            getMasterMeasureOperandIdentifiers(measure);
        if (!arithmeticMeasureOperands) {
            return false;
        }
        return arithmeticMeasureOperands.some(function (operandLocalIdentifier) {
            return arithmeticMeasureLocalIdentifierDeepMatch(dv, operandLocalIdentifier, predicate, context);
        });
    };
}
function matchHeaderUri(uri, header) {
    var headerUri = getMappingHeaderUri(header);
    return headerUri ? headerUri === uri : false;
}
function matchHeaderIdentifier(identifier, header) {
    var headerIdentifier = getMappingHeaderIdentifier(header);
    return headerIdentifier ? headerIdentifier === identifier : false;
}
function matchUri(uri, measure) {
    var simpleMeasureUri = measureUri(measure);
    return simpleMeasureUri ? simpleMeasureUri === uri : false;
}
function matchMeasureIdentifier(identifier, measure) {
    var simpleMeasureIdentifier = measureIdentifier(measure);
    return simpleMeasureIdentifier ? simpleMeasureIdentifier === identifier : false;
}
function matchDerivedMeasureByMasterUri(uri, measure, context) {
    var dv = context.dv;
    var masterMeasureLocalIdentifier = measureMasterIdentifier(measure);
    if (masterMeasureLocalIdentifier === undefined) {
        return false;
    }
    var masterMeasureHeader = dv.meta().measureDescriptor(masterMeasureLocalIdentifier);
    if (matchHeaderUri(uri, masterMeasureHeader)) {
        return true;
    }
    var masterMeasure = dv.def().measure(masterMeasureLocalIdentifier);
    return matchUri(uri, masterMeasure);
}
function matchDerivedMeasureByMasterIdentifier(identifier, measure, context) {
    var dv = context.dv;
    var masterMeasureLocalIdentifier = measureMasterIdentifier(measure);
    if (masterMeasureLocalIdentifier === undefined) {
        return false;
    }
    var masterMeasureHeader = dv.meta().measureDescriptor(masterMeasureLocalIdentifier);
    if (matchHeaderIdentifier(identifier, masterMeasureHeader)) {
        return true;
    }
    var masterMeasure = dv.def().measure(masterMeasureLocalIdentifier);
    return matchMeasureIdentifier(identifier, masterMeasure);
}
/**
 * Creates a new predicate that returns true for any header that belongs to either attribute or measure with the
 * provided URI.
 *
 * @public
 */
export function uriMatch(uri) {
    if (!uri) {
        return alwaysFalsePredicate;
    }
    return function (header, context) {
        var dv = context.dv;
        if (matchHeaderUri(uri, header)) {
            return true;
        }
        if (!isMeasureDescriptor(header)) {
            return false;
        }
        var measure = dv.def().measure(getMappingHeaderLocalIdentifier(header));
        if (!measure) {
            return false;
        }
        if (matchUri(uri, measure)) {
            return true;
        }
        return matchDerivedMeasureByMasterUri(uri, measure, context);
    };
}
/**
 * Creates a new predicate that returns true for any header that belongs to either attribute or measure with the
 * provided identifier.
 *
 * @public
 */
export function identifierMatch(identifier) {
    if (!identifier) {
        return alwaysFalsePredicate;
    }
    return function (header, context) {
        var dv = context.dv;
        if (isResultAttributeHeader(header)) {
            return false;
        }
        if (matchHeaderIdentifier(identifier, header)) {
            return true;
        }
        if (!isMeasureDescriptor(header)) {
            return false;
        }
        var measure = dv.def().measure(getMappingHeaderLocalIdentifier(header));
        if (!measure) {
            return false;
        }
        if (matchMeasureIdentifier(identifier, measure)) {
            return true;
        }
        return matchDerivedMeasureByMasterIdentifier(identifier, measure, context);
    };
}
/**
 * Creates a predicate that return true for any attribute result header with the provided name.
 *
 * @public
 */
export function attributeItemNameMatch(name) {
    if (!name) {
        return alwaysFalsePredicate;
    }
    return function (header, _context) {
        return isResultAttributeHeader(header)
            ? header.attributeHeaderItem && header.attributeHeaderItem.name === name
            : false;
    };
}
/**
 * Creates a new predicate that returns true for any header that belongs to either attribute or measure with the
 * provided local identifier.
 *
 * @public
 */
export function localIdentifierMatch(localIdOrMeasure) {
    if (!localIdOrMeasure) {
        return alwaysFalsePredicate;
    }
    var localId = typeof localIdOrMeasure === "string" ? localIdOrMeasure : measureLocalId(localIdOrMeasure);
    return function (header, _context) {
        if (!hasMappingHeaderLocalIdentifier(header)) {
            return false;
        }
        var headerLocalIdentifier = getMappingHeaderLocalIdentifier(header);
        return headerLocalIdentifier !== undefined && headerLocalIdentifier === localId;
    };
}
/**
 * Creates a new predicate that returns true for any header that belongs to either attribute or measure with the
 * provided object reference.
 *
 * @public
 */
export function objRefMatch(objRef) {
    return isIdentifierRef(objRef)
        ? HeaderPredicates.identifierMatch(objRef.identifier)
        : HeaderPredicates.uriMatch(objRef.uri);
}
/**
 * Creates a new predicate that returns true for any header that belongs to either attribute or measure matching
 * the provided object.
 *
 * If the object is empty or is not attribute, simple measure or object reference, the function returns predicate
 * that is always falsy.
 *
 * @param obj - the object to be checked
 *
 * @public
 */
export function objMatch(obj) {
    if (!obj) {
        return alwaysFalsePredicate;
    }
    if (isAttribute(obj)) {
        return function (header, context) {
            return localIdentifierMatch(attributeLocalId(obj))(header, context) ||
                objRefMatch(attributeDisplayFormRef(obj))(header, context);
        };
    }
    if (isSimpleMeasure(obj)) {
        return function (header, context) {
            return localIdentifierMatch(measureLocalId(obj))(header, context) ||
                objRefMatch(measureItem(obj))(header, context);
        };
    }
    if (isObjRef(obj)) {
        return objRefMatch(obj);
    }
    return alwaysFalsePredicate;
}
/**
 * Creates a new predicate that returns true of any arithmetic measure where measure with the provided URI
 * is used as an operand.
 *
 * @public
 */
export function composedFromUri(uri) {
    if (!uri) {
        return alwaysFalsePredicate;
    }
    return composedFromQualifier(uriMatch(uri));
}
/**
 * Creates a new predicate that returns true of any arithmetic measure where measure with the provided identifier
 * is used as an operand.
 *
 * @public
 */
export function composedFromIdentifier(identifier) {
    if (!identifier) {
        return alwaysFalsePredicate;
    }
    return composedFromQualifier(identifierMatch(identifier));
}
/**
 * Set of factory functions to create the most commonly-used {@link IHeaderPredicate | HeaderPredicates}.
 *
 * @public
 */
export var HeaderPredicates = {
    attributeItemNameMatch: attributeItemNameMatch,
    composedFromIdentifier: composedFromIdentifier,
    composedFromUri: composedFromUri,
    identifierMatch: identifierMatch,
    localIdentifierMatch: localIdentifierMatch,
    uriMatch: uriMatch,
    objRefMatch: objRefMatch,
    objMatch: objMatch,
};
//# sourceMappingURL=HeaderPredicateFactory.js.map