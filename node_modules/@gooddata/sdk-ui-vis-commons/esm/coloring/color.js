import { isAttributeDescriptor, isResultAttributeHeader } from "@gooddata/sdk-backend-spi";
import { DefaultColorPalette, getMappingHeaderLocalIdentifier, } from "@gooddata/sdk-ui";
import isEqual from "lodash/isEqual";
import isEmpty from "lodash/isEmpty";
/**
 * @internal
 */
function lighter(color, percent) {
    var t = percent < 0 ? 0 : 255;
    var p = Math.abs(percent);
    return Math.round((t - color) * p) + color;
}
/**
 * @internal
 */
function formatColor(red, green, blue) {
    return "rgb(" + red + "," + green + "," + blue + ")";
}
/**
 * @internal
 */
export function parseRGBColorCode(color) {
    var f = color.split(",");
    var R = parseInt(f[0].slice(4), 10);
    var G = parseInt(f[1], 10);
    var B = parseInt(f[2], 10);
    return { R: R, G: G, B: B };
}
/**
 * Source:
 *     http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
 *
 * @internal
 */
export function getLighterColor(color, percent) {
    var _a = parseRGBColorCode(color), R = _a.R, G = _a.G, B = _a.B;
    return formatColor(lighter(R, percent), lighter(G, percent), lighter(B, percent));
}
/**
 * @internal
 */
export function getLighterColorFromRGB(color, percent) {
    var r = color.r, g = color.g, b = color.b;
    return {
        r: lighter(r, percent),
        g: lighter(g, percent),
        b: lighter(b, percent)
    };
}
/**
 * Takes short or long format of HEX color and returns long format.
 * @param color - short `#123` or long `#112233` format
 * @returns long hex format `#112233`
 */
function convertToLongHexFormat(color) {
    if (color.length === 4) {
        var _a = color.split("").slice(1), r = _a[0], g = _a[1], b = _a[2];
        return "#" + r + r + g + g + b + b;
    }
    return color;
}
/**
 * @internal
 */
export function normalizeColorToRGB(color) {
    if (typeof color !== "string") {
        return color;
    }
    if (color.slice(0, 3) === "rgb") {
        return color.replace(/\s/g, "");
    }
    var hexPattern = /#([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})/i;
    return convertToLongHexFormat(color).replace(hexPattern, function (_prefix, r, g, b) {
        return "rgb(" + [r, g, b].map(function (value) { return parseInt(value, 16).toString(10); }).join(",") + ")";
    });
}
/**
 * @internal
 */
export function getColorPaletteFromColors(colors) {
    try {
        return colors.map(function (color, index) {
            var _a = parseRGBColorCode(normalizeColorToRGB(color)), R = _a.R, G = _a.G, B = _a.B;
            if (isNaN(R) || isNaN(G) || isNaN(B)) {
                throw Error;
            }
            return {
                guid: String(index),
                fill: {
                    r: R,
                    g: G,
                    b: B
                }
            };
        });
    }
    catch (_ignored) {
        return DefaultColorPalette;
    }
}
/**
 * @internal
 */
export function getRgbString(color) {
    return "rgb(" + color.fill.r + "," + color.fill.g + "," + color.fill.b + ")";
}
/**
 * @internal
 */
export function isCustomPalette(palette) {
    return !isEqual(palette, DefaultColorPalette);
}
/**
 * @internal
 */
export function getColorFromMapping(mappingHeader, colorMapping, dv) {
    if (!colorMapping) {
        return undefined;
    }
    var mapping = colorMapping.find(function (item) { return item.predicate(mappingHeader, { dv: dv }); });
    return mapping && mapping.color;
}
/**
 * @internal
 */
export function getColorByGuid(colorPalette, guid, index) {
    var inPalette = colorPalette.find(function (item) { return item.guid === guid; });
    return inPalette ? inPalette.fill : colorPalette[index % colorPalette.length].fill;
}
/**
 * @internal
 */
export function getRgbStringFromRGB(color) {
    return "rgb(" + color.r + "," + color.g + "," + color.b + ")";
}
/**
 * @internal
 */
export function parseRGBString(color) {
    var normalizedColor = normalizeColorToRGB(color);
    var result = /rgb\((.*)\)/.exec(normalizedColor);
    if (result === null) {
        return null;
    }
    var values = result[1];
    var _a = values.split(",").map(function (i) { return parseInt(i); }), r = _a[0], g = _a[1], b = _a[2];
    return { r: r, g: g, b: b };
}
/**
 * Creates new predicate for mapping colors to chart entities:
 *
 * -  if attribute header, URI is expected to match testValue
 * -  otherwise (attr or measure descriptor) expecting local identifier match
 *
 * @param testValue - right hand side to test against
 * @internal
 */
export function getColorMappingPredicate(testValue) {
    return function (header, _context) {
        if (isResultAttributeHeader(header)) {
            return testValue ? testValue === header.attributeHeaderItem.uri : false;
        }
        if (isAttributeDescriptor(header)) {
            return testValue ? testValue === header.attributeHeader.uri : false;
        }
        var headerLocalIdentifier = getMappingHeaderLocalIdentifier(header);
        return headerLocalIdentifier ? headerLocalIdentifier === testValue : false;
    };
}
/**
 * Applies color properties preferences. If palette is specified and non-empty, it is returned. Otherwise
 * non-empty colors are transformed into a palette and returned. If all else fails, default color palette
 * is returned
 *
 * @internal
 */
export function getValidColorPalette(colors, colorPalette) {
    if (colorPalette && !isEmpty(colorPalette)) {
        return colorPalette;
    }
    if (colors && !isEmpty(colors)) {
        return getColorPaletteFromColors(colors);
    }
    return DefaultColorPalette;
}
// For re-exporting in index.ts
// Create object here since TSC can't reexport external types used by getColorMappingPredicate
/**
 * @internal
 */
export var ColorUtils = {
    getColorByGuid: getColorByGuid,
    getColorMappingPredicate: getColorMappingPredicate
};
//# sourceMappingURL=color.js.map