import { __assign, __spreadArrays } from "tslib";
// (C) 2007-2021 GoodData Corporation
import clone from "lodash/clone";
import includes from "lodash/includes";
import isNil from "lodash/isNil";
import setWith from "lodash/setWith";
import { numberFormat } from "@gooddata/numberjs";
import escape from "lodash/escape";
import isEqual from "lodash/fp/isEqual";
import unescape from "lodash/unescape";
import { VisualizationTypes } from "@gooddata/sdk-ui";
export function parseValue(value) {
    var parsedValue = parseFloat(value);
    return isNaN(parsedValue) ? null : parsedValue;
}
export var immutableSet = function (dataSet, path, newValue) { return setWith(__assign({}, dataSet), path, newValue, clone); };
export var repeatItemsNTimes = function (array, n) {
    return new Array(n).fill(null).reduce(function (result) { return __spreadArrays(result, array); }, []);
};
export var unEscapeAngleBrackets = function (str) {
    return str && str.replace(/&lt;|&#60;/g, "<").replace(/&gt;|&#62;/g, ">");
};
export function isRotationInRange(rotation, min, max) {
    return rotation >= min && rotation <= max;
}
/**
 * @internal
 */
export var isColumnChart = isEqual(VisualizationTypes.COLUMN);
/**
 * @internal
 */
export var isBarChart = isEqual(VisualizationTypes.BAR);
/**
 * @internal
 */
export var isBulletChart = isEqual(VisualizationTypes.BULLET);
/**
 * @internal
 */
export var isLineChart = isEqual(VisualizationTypes.LINE);
/**
 * @internal
 */
export var isScatterPlot = isEqual(VisualizationTypes.SCATTER);
/**
 * @internal
 */
export var isPieChart = isEqual(VisualizationTypes.PIE);
/**
 * @internal
 */
export var isDonutChart = isEqual(VisualizationTypes.DONUT);
/**
 * @internal
 */
export var isPieOrDonutChart = function (type) { return isPieChart(type) || isDonutChart(type); };
/**
 * @internal
 */
export var isAreaChart = isEqual(VisualizationTypes.AREA);
/**
 * @internal
 */
export var isBubbleChart = isEqual(VisualizationTypes.BUBBLE);
/**
 * @internal
 */
export var isComboChart = function (type) {
    return isEqual(type, VisualizationTypes.COMBO) || isEqual(type, VisualizationTypes.COMBO2);
};
/**
 * @internal
 */
export var isTreemap = isEqual(VisualizationTypes.TREEMAP);
/**
 * @internal
 */
export var isHeatmap = isEqual(VisualizationTypes.HEATMAP);
/**
 * @internal
 */
export var isInvertedChartType = function (type) { return isBarChart(type) || isBulletChart(type); };
export var isChartSupported = function (type) { return includes(VisualizationTypes, type); };
export var isOneOfTypes = function (type, types) { return includes(types, type); };
export var stringifyChartTypes = function () {
    return Object.keys(VisualizationTypes)
        .reduce(function (acc, type) {
        acc.push(VisualizationTypes[type]);
        return acc;
    }, [])
        .join(", ");
};
export function formatLegendLabel(value, format, diff, numericSymbols) {
    if (format && format.includes("%")) {
        return numberFormat(value, "#,#0%");
    }
    var sign = Math.sign(value) === -1 ? "-" : "";
    var positiveValue = Math.abs(value);
    var formattingString = "";
    if (diff < 10) {
        formattingString += "[<1]0.00;[<10]#.#;[<100]#.#;";
    }
    var k = diff < 10000
        ? "[<999500]0;"
        : "[<1000]0;[<10000]#.#," + numericSymbols[0] + ";[<999500]#," + numericSymbols[0] + ";";
    var m = "[<10000000]#.#,," + numericSymbols[1] + ";[<999500000]#,," + numericSymbols[1] + ";";
    var b = "[<10000000000]#.#,,," + numericSymbols[2] + ";[<999500000000]#,,," + numericSymbols[2] + ";";
    var t = "[<10000000000000]#.#,,," + numericSymbols[3] + ";[>=10000000000000]#,,," + numericSymbols[3];
    formattingString += k + m + b + t;
    return sign + numberFormat(positiveValue, formattingString);
}
export var getPrimaryChartType = function (chartOptions) {
    var _a, _b, _c;
    var series = (_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.data) === null || _a === void 0 ? void 0 : _a.series) !== null && _b !== void 0 ? _b : [];
    var targetSeries = series.find(function (item) { return item.yAxis === 0; });
    return (_c = targetSeries === null || targetSeries === void 0 ? void 0 : targetSeries.type) !== null && _c !== void 0 ? _c : chartOptions.type;
};
export var unwrap = function (wrappedObject) {
    return wrappedObject[Object.keys(wrappedObject)[0]];
};
export function percentFormatter(value) {
    return isNil(value) ? "" : parseFloat(value.toFixed(2)) + "%";
}
export var isCssMultiLineTruncationSupported = function () {
    // support -webkit-line-clamp
    return "webkitLineClamp" in document.body.style;
};
export var customEscape = function (str) { return str && escape(unescape(str)); };
export var getAxesCounts = function (config) {
    var _a, _b, _c, _d;
    var hasSecondaryXAxis = config.secondary_xaxis && ((_b = (_a = config.secondary_xaxis) === null || _a === void 0 ? void 0 : _a.measures) === null || _b === void 0 ? void 0 : _b.length) !== 0;
    var hasSecondaryYAxis = config.secondary_yaxis && ((_d = (_c = config.secondary_yaxis) === null || _c === void 0 ? void 0 : _c.measures) === null || _d === void 0 ? void 0 : _d.length) !== 0;
    return [hasSecondaryXAxis ? 2 : 1, hasSecondaryYAxis ? 2 : 1];
};
//# sourceMappingURL=common.js.map