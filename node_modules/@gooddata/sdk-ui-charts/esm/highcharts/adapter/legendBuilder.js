import { __assign, __spreadArrays } from "tslib";
// (C) 2007-2021 GoodData Corporation
import pick from "lodash/pick";
import set from "lodash/set";
import { isAreaChart, isBubbleChart, isComboChart, isHeatmap, isLineChart, isOneOfTypes, isScatterPlot, isTreemap, } from "../chartTypes/_util/common";
import { VisualizationTypes } from "@gooddata/sdk-ui";
import { isStackedChart, getComboChartSeries, createDualAxesSeriesMapper } from "./legendHelpers";
import { supportedDualAxesChartTypes } from "../chartTypes/_chartOptions/chartCapabilities";
import { DEFAULT_LEGEND_CONFIG, } from "@gooddata/sdk-ui-vis-commons";
function isHeatmapWithMultipleValues(chartOptions) {
    var _a, _b;
    var type = chartOptions.type;
    var dataClasses = (_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.colorAxis) === null || _a === void 0 ? void 0 : _a.dataClasses) !== null && _b !== void 0 ? _b : [];
    return isHeatmap(type) && dataClasses.length > 1;
}
export function shouldLegendBeEnabled(chartOptions) {
    var _a, _b;
    var seriesLength = (_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.data) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.length;
    var type = chartOptions.type, hasStackByAttribute = chartOptions.hasStackByAttribute, hasViewByAttribute = chartOptions.hasViewByAttribute;
    var hasMoreThanOneSeries = seriesLength > 1;
    var isLineChartStacked = isLineChart(type) && hasStackByAttribute;
    var isStacked = isStackedChart(chartOptions);
    var sliceTypes = [VisualizationTypes.PIE, VisualizationTypes.DONUT];
    var isSliceChartWithViewByAttributeOrMultipleMeasures = isOneOfTypes(type, sliceTypes) && (hasViewByAttribute || chartOptions.data.series[0].data.length > 1);
    var isBubbleWithViewByAttribute = isBubbleChart(type) && hasViewByAttribute;
    var isScatterPlotWithAttribute = isScatterPlot(type) && chartOptions.data.series[0].name;
    var isTreemapWithViewByAttribute = isTreemap(type) && hasViewByAttribute;
    var isTreemapWithManyCategories = isTreemap(type) && chartOptions.data.categories.length > 1;
    return (hasMoreThanOneSeries ||
        isSliceChartWithViewByAttributeOrMultipleMeasures ||
        isStacked ||
        isLineChartStacked ||
        isScatterPlotWithAttribute ||
        isTreemapWithViewByAttribute ||
        isBubbleWithViewByAttribute ||
        isTreemapWithManyCategories ||
        isHeatmapWithMultipleValues(chartOptions));
}
export function getLegendItems(chartOptions) {
    var _a, _b;
    var type = chartOptions.type;
    var firstSeriesDataTypes = [
        VisualizationTypes.PIE,
        VisualizationTypes.DONUT,
        VisualizationTypes.TREEMAP,
        VisualizationTypes.FUNNEL,
        VisualizationTypes.SCATTER,
    ];
    if (isHeatmap(type)) {
        var dataClasses = (_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.colorAxis) === null || _a === void 0 ? void 0 : _a.dataClasses) !== null && _b !== void 0 ? _b : [];
        return dataClasses.map(function (dataClass, index) {
            var from = dataClass.from, to = dataClass.to;
            var color = dataClass.color; // wa are not using Gradient
            var range = {
                from: from,
                to: to,
            };
            return {
                range: range,
                color: color,
                legendIndex: index,
            };
        });
    }
    var legendDataSource = isOneOfTypes(type, firstSeriesDataTypes)
        ? chartOptions.data.series[0].data
        : chartOptions.data.series;
    var pickedProps = ["name", "color", "legendIndex"];
    if (isOneOfTypes(type, supportedDualAxesChartTypes)) {
        // 'yAxis' helps to distinguish primary and secondary axes
        pickedProps = __spreadArrays(pickedProps, ["yAxis"]);
    }
    if (isComboChart(type)) {
        pickedProps = __spreadArrays(pickedProps, ["type"]);
    }
    return legendDataSource
        .filter(function (legendDataSourceItem) { return legendDataSourceItem.showInLegend !== false; })
        .map(function (legendDataSourceItem) { return pick(legendDataSourceItem, pickedProps); });
}
export default function buildLegendOptions(legendConfig, chartOptions) {
    var _a, _b;
    if (legendConfig === void 0) { legendConfig = {}; }
    var defaultLegendConfigByType = {};
    var rightLegendCharts = [
        VisualizationTypes.SCATTER,
        VisualizationTypes.TREEMAP,
        VisualizationTypes.BUBBLE,
        VisualizationTypes.HEATMAP,
    ];
    var defaultTopLegendCharts = [
        VisualizationTypes.COLUMN,
        VisualizationTypes.BAR,
        VisualizationTypes.BULLET,
        VisualizationTypes.LINE,
        VisualizationTypes.AREA,
        VisualizationTypes.PIE,
        VisualizationTypes.DONUT,
    ];
    if (legendConfig.position === "auto" || !legendConfig.position) {
        if (isOneOfTypes(chartOptions.type, rightLegendCharts)) {
            set(defaultLegendConfigByType, "position", "right");
        }
        if (isOneOfTypes(chartOptions.type, defaultTopLegendCharts) && !chartOptions.hasStackByAttribute) {
            set(defaultLegendConfigByType, "position", "top");
        }
    }
    var baseConfig = __assign(__assign(__assign({}, DEFAULT_LEGEND_CONFIG), legendConfig), defaultLegendConfigByType);
    var isLegendEnabled = shouldLegendBeEnabled(chartOptions);
    return __assign(__assign({}, baseConfig), { enabled: baseConfig.enabled && isLegendEnabled, toggleEnabled: isLegendEnabled, format: (_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.title) === null || _a === void 0 ? void 0 : _a.format) !== null && _b !== void 0 ? _b : "", items: getLegendItems(chartOptions), enableBorderRadius: createItemBorderRadiusPredicate(chartOptions.type), seriesMapper: createSeriesMapper(chartOptions.type) });
}
/**
 * Given chart type, this creates predicate to turn legend item border radius on or off. The border
 * radius is set to make legend item indicators appear as circles instead of squares.
 *
 * The predicate is crafted so that line and area charts have indicators as circles. This also stands for
 * combo chart - line or area items within combo must use circles.
 *
 * @param chartType - top-level chart type (combo chart will have legend items of different types)
 */
function createItemBorderRadiusPredicate(chartType) {
    if (isLineChart(chartType) || isAreaChart(chartType)) {
        /*
         * It is clear that all items are of same type and should have indicators as circles.
         */
        return true;
    }
    else if (isComboChart(chartType)) {
        /*
         * For combo chart, determine item-by-item
         */
        return function (item) {
            return isLineChart(item.type) || isAreaChart(item.type);
        };
    }
    return false;
}
/**
 * Given chart type, this function creates a series mapper which will alter previously created legend
 * items. This code was previously insight the legend implementation. It is extracted here to make legends
 * visualization agnostic.
 *
 * The big question is - why is this mapper even needed, why not creating the legend items correctly the first time?
 * It is likely that the code was glued-in while implementing combo and dual axes charts. Perhaps better way is to
 * refactor the legend builders (which can be chart-specific) to create the legend items correctly.
 */
function createSeriesMapper(chartType) {
    if (isComboChart(chartType)) {
        return getComboChartSeries;
    }
    return createDualAxesSeriesMapper(chartType);
}
//# sourceMappingURL=legendBuilder.js.map