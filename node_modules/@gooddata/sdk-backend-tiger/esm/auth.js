import { __awaiter, __extends, __generator } from "tslib";
import { setAxiosAuthorizationToken } from "@gooddata/api-client-tiger";
import { StatusCodes as HttpStatusCodes } from "http-status-codes";
import { convertApiError } from "./utils/errorHandling";
/**
 * Base for other IAuthenticationProvider implementations.
 *
 * @public
 */
var TigerAuthProviderBase = /** @class */ (function () {
    function TigerAuthProviderBase() {
    }
    TigerAuthProviderBase.prototype.deauthenticate = function (context) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var client, logoutUrl, error_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        client = context.client;
                        logoutUrl = createTigerDeauthenticationUrl(context.backend, window.location);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.axios.post(logoutUrl)];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _b.sent();
                        if (((_a = error_1.response) === null || _a === void 0 ? void 0 : _a.status) === HttpStatusCodes.METHOD_NOT_ALLOWED) {
                            // this means we are on tiger >= 1.1 -> we must redirect to the /logout resource instead of POSTing to it
                            return [2 /*return*/, window.location.assign(logoutUrl)];
                        }
                        // eslint-disable-next-line no-console
                        console.debug("Error during logout", error_1);
                        throw convertApiError(error_1);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    TigerAuthProviderBase.prototype.getCurrentPrincipal = function (context) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.principal) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.obtainCurrentPrincipal(context)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, this.principal || null];
                }
            });
        });
    };
    TigerAuthProviderBase.prototype.obtainCurrentPrincipal = function (context) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var profile;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.loadProfile(context)];
                    case 1:
                        profile = _b.sent();
                        this.principal = {
                            userId: (_a = profile.userId) !== null && _a !== void 0 ? _a : "n/a",
                            userMeta: profile,
                        };
                        return [2 /*return*/];
                }
            });
        });
    };
    /*
     * TODO: this API is not yet part of OAS spec. eventually replace it with call to api-tiger-client
     */
    TigerAuthProviderBase.prototype.loadProfile = function (context) {
        return __awaiter(this, void 0, void 0, function () {
            var client, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client = context.client;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.axios.get("/api/profile")];
                    case 2: return [2 /*return*/, (_a.sent()).data];
                    case 3:
                        err_1 = _a.sent();
                        throw convertApiError(err_1);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return TigerAuthProviderBase;
}());
export { TigerAuthProviderBase };
/**
 * This implementation of authentication provider uses an API Token as bearer of authentication. You can provide token
 * at construction time and it will be passed on all calls to Tiger APIs
 *
 * This is a go-to authentication provider for command-line applications. While nothing stops you from using
 * this provider in UI applications, keep in mind that this is discouraged due to security holes it leads to; having
 * the token hardcoded in a UI application means anyone can find it and use it for themselves.
 *
 * @public
 */
var TigerTokenAuthProvider = /** @class */ (function (_super) {
    __extends(TigerTokenAuthProvider, _super);
    function TigerTokenAuthProvider(apiToken) {
        var _this = _super.call(this) || this;
        _this.apiToken = apiToken;
        return _this;
    }
    TigerTokenAuthProvider.prototype.initializeClient = function (client) {
        setAxiosAuthorizationToken(client.axios, this.apiToken);
    };
    TigerTokenAuthProvider.prototype.authenticate = function (context) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.obtainCurrentPrincipal(context)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.principal];
                }
            });
        });
    };
    return TigerTokenAuthProvider;
}(TigerAuthProviderBase));
export { TigerTokenAuthProvider };
/**
 * This implementation of authentication provider defers the responsibility for performing authentication
 * to the context in which it exists. In other words it expects that the application will take care of driving
 * the authentication and creating a correct session in which the Tiger backend can make authenticated calls.
 *
 * This is a go-to authentication provider for UI applications. The entire flow is as follows:
 *
 * -  The application that uses backend configured with this provider must expect that some of the backend
 *    calls with result in NotAuthenticated exception.
 *
 * -  The exception will contain `loginUrl` set to the URL on the current origin - this is location of the login page.
 *
 * -  The application must redirect the entire window to this URL appended with `redirectTo` query parameter.
 *
 * -  The value of this parameter is the application's URL that will be used as a return location.
 *
 * -  The login page will start and drive the OIDC authentication flow. Once the flow finishes and session
 *    is set up, the login page will redirect back to the application.
 *
 * You may use the provider's ability to use passed `NotAuthenticatedHandler` function. This will be called
 * every time a NotAuthenticated error is raised by the backend. Your application can pass a custom handler of
 * this event - typically something that will start driving the authentication from a single place.
 *
 * Note: the not authenticated handler MAY be called many times in succession so you may want to wrap it in a
 * call guard or in a debounce.
 *
 * @remarks See {@link redirectToTigerAuthentication} for implementation of the NotAuthenticated handler which
 *  you may use with this provider.
 * @public
 */
var ContextDeferredAuthProvider = /** @class */ (function (_super) {
    __extends(ContextDeferredAuthProvider, _super);
    function ContextDeferredAuthProvider(notAuthenticatedHandler) {
        var _this = _super.call(this) || this;
        _this.notAuthenticatedHandler = notAuthenticatedHandler;
        _this.onNotAuthenticated = function (context, error) {
            var _a;
            (_a = _this.notAuthenticatedHandler) === null || _a === void 0 ? void 0 : _a.call(_this, context, error);
        };
        return _this;
    }
    // eslint-disable-next-line sonarjs/no-identical-functions
    ContextDeferredAuthProvider.prototype.authenticate = function (context) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.obtainCurrentPrincipal(context)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.principal];
                }
            });
        });
    };
    return ContextDeferredAuthProvider;
}(TigerAuthProviderBase));
export { ContextDeferredAuthProvider };
/**
 * Given tiger backend, authentication flow details and current location, this function creates URL where the
 * browser should redirect to start authentication flow with correct return address.
 *
 * The current location is essential to determine whether the return redirect should contain absolute or
 * related return path:
 *
 * -  When running on same origin, then use relative path
 * -  When running on different origin, then use absolute path
 *
 * @param backend - an instance of analytical backend
 * @param authenticationFlow - details about the tiger authentication flow
 * @param location - current location
 * @public
 */
export function createTigerAuthenticationUrl(backend, authenticationFlow, location) {
    var _a, _b, _c;
    var host = location.protocol + "//" + location.host;
    var returnAddress = "" + ((_a = location.pathname) !== null && _a !== void 0 ? _a : "") + ((_b = location.search) !== null && _b !== void 0 ? _b : "") + ((_c = location.hash) !== null && _c !== void 0 ? _c : "");
    var backendHostname = backend.config.hostname;
    if (backendHostname && backendHostname !== host) {
        // different origin. app must redirect to the backend hostname
        host = backendHostname;
        // but have return to current hostname
        returnAddress = location.href;
    }
    return "" + host + authenticationFlow.loginUrl + "?" + authenticationFlow.returnRedirectParam + "=" + encodeURIComponent(returnAddress);
}
/**
 * Given tiger backend and current location, this function creates URL where the
 * browser should redirect to start deauthentication (logout) flow.
 *
 * The current location is essential to determine the URL should point:
 *
 * -  When running on same origin, then use relative path
 * -  When running on different origin, then use absolute path to the proper origin
 *
 * @param backend - an instance of analytical backend
 * @param location - current location
 * @public
 */
export function createTigerDeauthenticationUrl(backend, location) {
    var host = location.protocol + "//" + location.host;
    var backendHostname = backend.config.hostname;
    if (backendHostname && backendHostname !== host) {
        // different origin. app must redirect to the backend hostname
        host = backendHostname;
    }
    return host + "/logout";
}
/**
 * Given authentication context and the authentication error, this implementation of `NotAuthenticatedHandler`
 * will redirect current window to location where Tiger authentication flow will start.
 *
 * The location will be setup with correct return address so that when the flow finishes successfully, the
 * browser window will be redirected from whence it came.
 *
 * @remarks See also {@link createTigerAuthenticationUrl}; this function is used to construct the URL. You may use
 *  it when build your own handler.
 * @param context - authentication context
 * @param error - not authenticated error, must contain the `authenticationFlow` information otherwise the
 *  handler just logs an error and does nothing
 * @public
 */
export function redirectToTigerAuthentication(context, error) {
    if (!error.authenticationFlow) {
        // eslint-disable-next-line no-console
        console.error("Analytical Backend did not provide detail where to start authentication flow. ");
        return;
    }
    window.location.href = createTigerAuthenticationUrl(context.backend, error.authenticationFlow, window.location);
}
//# sourceMappingURL=auth.js.map