// (C) 2019-2021 GoodData Corporation
import { __awaiter, __generator } from "tslib";
import { MetadataUtilities, } from "@gooddata/api-client-tiger";
import values from "lodash/values";
import { convertAttribute, convertDateAttribute, convertDateDataset, } from "../../../convertors/fromBackend/CatalogConverter";
import { addRsqlFilterToParams } from "./rsqlFilter";
function lookupRelatedObject(included, id, type) {
    if (!included) {
        return;
    }
    return included === null || included === void 0 ? void 0 : included.find(function (item) { return item.type === type && item.id === id; });
}
function getAttributeLabels(attribute, included) {
    var _a, _b;
    var labelsRefs = (_b = (_a = attribute.relationships) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.data;
    return labelsRefs
        .map(function (ref) {
        var obj = lookupRelatedObject(included, ref.id, ref.type);
        if (!obj) {
            return;
        }
        return obj;
    })
        .filter(function (obj) { return obj !== undefined; });
}
function isGeoLabel(label) {
    /*
     * TODO: TIGER-HACK this is temporary way to identify labels with geo pushpin; normally this should be done
     *  using some indicator on the metadata object. for sakes of speed & after agreement with tiger team
     *  falling back to use of id convention.
     */
    return label.id.search(/^.*\.geo__/) > -1;
}
function createNonDateAttributes(attributes) {
    var nonDateAttributes = attributes.data.filter(function (attr) { var _a; return ((_a = attr.attributes) === null || _a === void 0 ? void 0 : _a.granularity) === undefined; });
    return nonDateAttributes.map(function (attribute) {
        var allLabels = getAttributeLabels(attribute, attributes.included);
        var geoLabels = allLabels.filter(isGeoLabel);
        // exactly one label is guaranteed to be primary
        var defaultLabel = allLabels.filter(function (label) { return label.attributes.primary; })[0];
        return convertAttribute(attribute, defaultLabel, geoLabels, allLabels);
    });
}
function identifyDateDatasets(dateAttributes, included) {
    var datasets = {};
    dateAttributes.forEach(function (attribute) {
        var _a, _b;
        var ref = (_b = (_a = attribute.relationships) === null || _a === void 0 ? void 0 : _a.dataset) === null || _b === void 0 ? void 0 : _b.data;
        if (!ref) {
            return;
        }
        var dataset = lookupRelatedObject(included, ref.id, ref.type);
        if (!dataset) {
            return;
        }
        var entry = datasets[ref.id];
        if (!entry) {
            datasets[ref.id] = {
                dataset: dataset,
                attributes: [attribute],
            };
        }
        else {
            entry.attributes.push(attribute);
        }
    });
    return values(datasets);
}
function createDateDatasets(attributes) {
    var dateAttributes = attributes.data.filter(function (attr) { var _a; return ((_a = attr.attributes) === null || _a === void 0 ? void 0 : _a.granularity) !== undefined; });
    var dateDatasets = identifyDateDatasets(dateAttributes, attributes.included);
    return dateDatasets.map(function (dd) {
        var catalogDateAttributes = dd.attributes.map(function (attribute) {
            var labels = getAttributeLabels(attribute, attributes.included);
            var defaultLabel = labels[0];
            return convertDateAttribute(attribute, defaultLabel, labels);
        });
        return convertDateDataset(dd.dataset, catalogDateAttributes);
    });
}
export function loadAttributesAndDateDatasets(client, workspaceId, rsqlFilter, loadAttributes, loadDateDatasets) {
    return __awaiter(this, void 0, void 0, function () {
        var includeObjects, params, attributes, catalogItems, nonDateAttributes, dateDatasets;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    includeObjects = ["labels"];
                    if (loadDateDatasets) {
                        includeObjects.push("datasets");
                    }
                    params = addRsqlFilterToParams({ workspaceId: workspaceId }, rsqlFilter);
                    return [4 /*yield*/, MetadataUtilities.getAllPagesOf(client, client.workspaceObjects.getAllEntitiesAttributes, params, { query: { include: includeObjects.join(",") } }).then(MetadataUtilities.mergeEntitiesResults)];
                case 1:
                    attributes = _a.sent();
                    catalogItems = [];
                    if (loadAttributes) {
                        nonDateAttributes = createNonDateAttributes(attributes);
                        catalogItems.push.apply(catalogItems, nonDateAttributes);
                    }
                    if (loadDateDatasets) {
                        dateDatasets = createDateDatasets(attributes);
                        catalogItems.push.apply(catalogItems, dateDatasets);
                    }
                    return [2 /*return*/, catalogItems];
            }
        });
    });
}
//# sourceMappingURL=datasetLoader.js.map