import { __assign } from "tslib";
// (C) 2007-2021 GoodData Corporation
import { ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum, SimpleMeasureDefinitionMeasureAggregationEnum, } from "@gooddata/api-client-tiger";
import { isArithmeticMeasureDefinition, isMeasureDefinition, isPoPMeasureDefinition, isPreviousPeriodMeasureDefinition, } from "@gooddata/sdk-model";
import compact from "lodash/compact";
import { InvariantError } from "ts-invariant";
import { toDateDataSetQualifier, toLabelQualifier, toFactQualifier, toLocalIdentifier, } from "../ObjRefConverter";
import { convertFilter } from "./FilterConverter";
export function convertMeasure(measure) {
    var definition = measure.measure.definition;
    var convertedDefinition = convertMeasureDefinition(definition);
    var format = getFormat(measure);
    var formatProp = format ? { format: format } : {};
    var alias = measure.measure.alias ? measure.measure.alias : measure.measure.title;
    var aliasProp = alias ? { alias: alias } : {};
    return __assign(__assign({ localIdentifier: measure.measure.localIdentifier, definition: convertedDefinition }, aliasProp), formatProp);
}
function convertMeasureDefinition(definition) {
    if (isMeasureDefinition(definition)) {
        return convertSimpleMeasureDefinition(definition);
    }
    else if (isPoPMeasureDefinition(definition)) {
        return convertPopMeasureDefinition(definition);
    }
    else if (isPreviousPeriodMeasureDefinition(definition)) {
        return convertPreviousPeriodMeasureDefinition(definition);
    }
    else if (isArithmeticMeasureDefinition(definition)) {
        return convertArithmeticMeasureDefinition(definition);
    }
    else {
        throw Error("The measure definition is not supported: " + JSON.stringify(definition));
    }
}
function convertAggregation(aggregation) {
    if (!aggregation) {
        return undefined;
    }
    if (aggregation === "sum") {
        return SimpleMeasureDefinitionMeasureAggregationEnum.SUM;
    }
    if (aggregation === "avg") {
        return SimpleMeasureDefinitionMeasureAggregationEnum.AVG;
    }
    if (aggregation === "count") {
        return SimpleMeasureDefinitionMeasureAggregationEnum.COUNT;
    }
    if (aggregation === "approximate_count") {
        return SimpleMeasureDefinitionMeasureAggregationEnum.APPROXIMATECOUNT;
    }
    if (aggregation === "max") {
        return SimpleMeasureDefinitionMeasureAggregationEnum.MAX;
    }
    if (aggregation === "median") {
        return SimpleMeasureDefinitionMeasureAggregationEnum.MEDIAN;
    }
    if (aggregation === "min") {
        return SimpleMeasureDefinitionMeasureAggregationEnum.MIN;
    }
    return SimpleMeasureDefinitionMeasureAggregationEnum.RUNSUM;
}
function convertSimpleMeasureDefinition(definition) {
    var measureDefinition = definition.measureDefinition;
    var filters = measureDefinition.filters
        ? compact(measureDefinition.filters.map(convertFilter)) // measureDefinition.filters is IMeasureFilter, it contains only date and attribute filter, equally result contains this subset, it corresponds to type FilterDefinitionForSimpleMeasure
        : [];
    var filtersProp = filters.length ? { filters: filters } : {};
    var aggregation = convertAggregation(measureDefinition.aggregation);
    var aggregationProp = aggregation ? { aggregation: aggregation } : {};
    var computeRatio = measureDefinition.computeRatio;
    var computeRatioProp = computeRatio ? { computeRatio: computeRatio } : {};
    var measureRef = measureDefinition.item;
    return {
        measure: __assign(__assign(__assign({ item: toFactQualifier(measureRef) }, filtersProp), aggregationProp), computeRatioProp),
    };
}
function convertPopMeasureDefinition(definition) {
    var popMeasureDefinition = definition.popMeasureDefinition;
    var attributeRef = popMeasureDefinition.popAttribute;
    return {
        overPeriodMeasure: {
            measureIdentifier: toLocalIdentifier(popMeasureDefinition.measureIdentifier),
            dateAttributes: [
                {
                    attribute: toLabelQualifier(attributeRef),
                    periodsAgo: 1,
                },
            ],
        },
    };
}
function convertPreviousPeriodMeasureDefinition(definition) {
    var previousPeriodMeasure = definition.previousPeriodMeasure;
    return {
        previousPeriodMeasure: {
            measureIdentifier: toLocalIdentifier(previousPeriodMeasure.measureIdentifier),
            dateDatasets: previousPeriodMeasure.dateDataSets.map(function (dateDataSet) {
                var datasetRef = dateDataSet.dataSet;
                return {
                    dataset: toDateDataSetQualifier(datasetRef),
                    periodsAgo: dateDataSet.periodsAgo,
                };
            }),
        },
    };
}
function convertArithmeticMeasureOperator(operator) {
    switch (operator) {
        case "sum":
            return ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum.SUM;
        case "difference":
            return ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum.DIFFERENCE;
        case "multiplication":
            return ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum.MULTIPLICATION;
        case "ratio":
            return ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum.RATIO;
        case "change":
            return ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum.CHANGE;
        default:
            throw new InvariantError("Unknown arithmetic measure operator \"" + operator + "\"");
    }
}
function convertArithmeticMeasureDefinition(definition) {
    var arithmeticMeasure = definition.arithmeticMeasure;
    return {
        arithmeticMeasure: {
            measureIdentifiers: arithmeticMeasure.measureIdentifiers.map(toLocalIdentifier),
            operator: convertArithmeticMeasureOperator(arithmeticMeasure.operator),
        },
    };
}
function getFormat(measure) {
    var definition = measure.measure.definition;
    var measureFormat = measure.measure.format;
    if (isArithmeticMeasureDefinition(definition) && definition.arithmeticMeasure.operator === "change") {
        return "#,##0.00%";
    }
    var predefinedFormat = isMeasureDefinition(definition) ? getPredefinedFormat(definition) : undefined;
    return predefinedFormat || measureFormat;
}
function getPredefinedFormat(definition) {
    var measureDefinition = definition.measureDefinition;
    // should we prefer format defined on measure? If so, fix computeRatio format in AD
    return measureDefinition.computeRatio
        ? "#,##0.00%"
        : measureDefinition.aggregation === "count"
            ? "#,##0"
            : null;
}
//# sourceMappingURL=MeasureConverter.js.map