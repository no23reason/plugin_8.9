import { isLocalIdRef, isMeasureValueFilter, isRankingFilter, localIdRef, measureDoesComputeRatio, measureLocalId, modifySimpleMeasure, filterMeasureRef, } from "@gooddata/sdk-model";
import compact from "lodash/compact";
import { convertMeasure } from "./MeasureConverter";
import { convertFilter, newFilterWithApplyOnResult } from "./FilterConverter";
/**
 * Return the actual measure which should be used for measure based filtering, together with the info how the
 * corresponding filter should be applied (`undefined` means default application).
 */
function getActualFilteredMeasureInfo(computeRatioMeasureNumerators, measure) {
    var updatedFilteredMeasure = isLocalIdRef(measure)
        ? computeRatioMeasureNumerators.get(measure.localIdentifier)
        : undefined;
    return updatedFilteredMeasure === undefined
        ? [measure, undefined]
        : [localIdRef(measureLocalId(updatedFilteredMeasure)), false];
}
/**
 * Find those ratio measures which are used in some measure based filter. For each such measure create its updated
 * version with ratio computation off and with new local identifier. These new auxiliary measures are meant to be used
 * as actual base for their respective filters which should be applied on source data (instead of the result) so that
 * both numerator and denominator of the ratio measure are actually filtered.
 *
 * Return mapping from the original local identifiers to new auxiliary measures.
 */
function determineComputeRatioMeasureNumerators(afmMeasures, filters) {
    var filteredLocalMeasures = filters
        .map(filterMeasureRef)
        .filter(isLocalIdRef)
        .map(function (m) { return m.localIdentifier; });
    return new Map(afmMeasures
        .filter(measureDoesComputeRatio)
        .filter(function (m) { return filteredLocalMeasures.includes(measureLocalId(m)); })
        .map(function (measure) {
        var measureNumerator = modifySimpleMeasure(measure, function (m) { return m.noRatio().defaultLocalId(); });
        return [measureLocalId(measure), measureNumerator];
    }));
}
/**
 * Converts internal `afmFilters` to backend AFM filters. Those filters that reference some compute ratio measure from
 * `afmMeasures` will be handled specially (see `determineComputeRatioMeasureNumerators`) and will also lead to `auxMeasures`
 * being generated (intended to be used by the callers in crafting the final backend AFM).
 */
export function convertAfmFilters(afmMeasures, afmFilters) {
    var computeRatioMeasureNumerators = determineComputeRatioMeasureNumerators(afmMeasures, afmFilters);
    var transformedFilters = afmFilters.map(function (filter) {
        // TODO Improve accessors and factory methods for measure based filters.
        if (isMeasureValueFilter(filter)) {
            var _a = getActualFilteredMeasureInfo(computeRatioMeasureNumerators, filter.measureValueFilter.measure), filteredMeasure = _a[0], applyOnResult = _a[1];
            var condition = filter.measureValueFilter.condition;
            var transformedFilter = { measureValueFilter: { measure: filteredMeasure, condition: condition } };
            return newFilterWithApplyOnResult(transformedFilter, applyOnResult);
        }
        else if (isRankingFilter(filter)) {
            var _b = getActualFilteredMeasureInfo(computeRatioMeasureNumerators, filter.rankingFilter.measure), filteredMeasure = _b[0], applyOnResult = _b[1];
            var _c = filter.rankingFilter, attributes = _c.attributes, operator = _c.operator, value = _c.value;
            var transformedFilter = {
                rankingFilter: { measure: filteredMeasure, attributes: attributes, operator: operator, value: value },
            };
            return newFilterWithApplyOnResult(transformedFilter, applyOnResult);
        }
        else {
            return filter;
        }
    });
    return {
        filters: compact(transformedFilters.map(convertFilter)),
        auxMeasures: Array.from(computeRatioMeasureNumerators.values()).map(convertMeasure),
    };
}
//# sourceMappingURL=AfmFiltersConverter.js.map