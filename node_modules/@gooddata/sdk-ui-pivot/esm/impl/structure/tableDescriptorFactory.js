import { __spreadArrays } from "tslib";
import { isAttributeDescriptor, } from "@gooddata/sdk-backend-spi";
import invariant from "ts-invariant";
import range from "lodash/range";
import { isSeriesCol, } from "./tableDescriptorTypes";
import { createColDefsFromTableDescriptor } from "./colDefFactory";
function createDataColRootGroup(scopingAttributes) {
    return {
        type: "rootCol",
        id: "root",
        fullIndexPathToHere: [0],
        children: [],
        groupingAttributes: scopingAttributes,
    };
}
function colDescriptorAndHeaders(col) {
    if (isSeriesCol(col)) {
        invariant(col.seriesDescriptor.attributeHeaders);
        invariant(col.seriesDescriptor.attributeDescriptors);
        return {
            attributeHeaders: col.seriesDescriptor.attributeHeaders,
            attributeDescriptors: col.seriesDescriptor.attributeDescriptors,
        };
    }
    else {
        return {
            attributeHeaders: col.headersToHere,
            attributeDescriptors: col.descriptorsToHere,
        };
    }
}
/**
 * Given a list of leaf columns and number of grouping levels, this function will create the
 * column groups and establish linkage between them.
 *
 * It does this by traversing the leaf columns and for each of the leaf column iterates over all
 * scoping information for the data series backing the column. The scoping information is what code
 * needs to create/populate the groups.
 *
 * The scoping can be done on multiple 'levels' from from root towards the leaves. So
 * for each attribute code checks whether a group already exists on that level, if not it creates one and
 * remembers that group as parentGroup for the next iteration.
 *
 */
function groupColumns(bottomColumns, scopingAttributes, limitLevels) {
    // this function should not be called if there is no need to create any groups
    invariant(scopingAttributes.length > 0);
    var levels = limitLevels !== undefined ? limitLevels : scopingAttributes.length;
    var root = createDataColRootGroup(scopingAttributes);
    // initialize grouping levels where code will keep pushing the new/updated groups. it is
    // the pkToGroup is here for quicker lookups. the groups list is there because the result
    // must be list of groups in order which they were created.
    var columnGroupLevels = range(levels).map(function (_) { return ({
        pkToGroup: {},
        groups: [],
    }); });
    var allColumns = __spreadArrays(bottomColumns, [root]);
    var groupId = 0;
    for (var _i = 0, bottomColumns_1 = bottomColumns; _i < bottomColumns_1.length; _i++) {
        var leaf = bottomColumns_1[_i];
        var _a = colDescriptorAndHeaders(leaf), attributeHeaders = _a.attributeHeaders, attributeDescriptors = _a.attributeDescriptors;
        // if any of these bomb then there possibly a bug in the data access infrastructure. that's because
        // the code can get here only if there are some data series scoping attributes. and in that case,
        // by contract each series will contain non empty attributeHeaders and attributeDescriptors
        invariant(attributeHeaders !== undefined);
        invariant(attributeDescriptors !== undefined);
        var parentGroup = root;
        var pathToGroup = "";
        for (var level = 0; level < levels; level++) {
            // see if a group for attribute element on the current level already exists (it will happen
            // when there are multiple measures in the table). if it exists, remember it as parentGroup
            // for the next iteration. if this is first
            pathToGroup += attributeHeaders[level].attributeHeaderItem.uri;
            var groupLevel = columnGroupLevels[level];
            var currentGroup = groupLevel.pkToGroup[pathToGroup];
            if (!currentGroup) {
                var fullIndexPathToHere = parentGroup
                    ? __spreadArrays(parentGroup.fullIndexPathToHere, [parentGroup.children.length]) : [groupLevel.groups.length];
                currentGroup = {
                    type: "scopeCol",
                    id: "g_" + groupId++,
                    attributeDescriptor: attributeDescriptors[level],
                    header: attributeHeaders[level],
                    descriptorsToHere: attributeDescriptors.slice(0, level),
                    headersToHere: attributeHeaders.slice(0, level),
                    children: [],
                    fullIndexPathToHere: fullIndexPathToHere,
                };
                groupLevel.pkToGroup[pathToGroup] = currentGroup;
                groupLevel.groups.push(currentGroup);
                allColumns.push(currentGroup);
                if (parentGroup) {
                    parentGroup.children.push(currentGroup);
                }
            }
            parentGroup = currentGroup;
        }
        // now insert the leaf itself. if code gets here and blows up then there is something
        // very wrong in the funky loop above.
        invariant(parentGroup !== undefined);
        leaf.fullIndexPathToHere = __spreadArrays(parentGroup.fullIndexPathToHere, [parentGroup.children.length]);
        parentGroup.children.push(leaf);
    }
    return {
        groupingAttributes: scopingAttributes,
        rootColumns: [root],
        allColumns: allColumns,
        leafColumns: bottomColumns,
    };
}
/**
 * This function creates bottom-most column descriptors from column attributes. It essentially creates the bottom-most
 * {@link ScopeCol} which would normally host the measure columns.
 */
function createColumnDescriptorsWhenNoMeasures(dv) {
    var _a, _b;
    var descriptors = dv.meta().attributeDescriptorsForDim(1);
    var headers = dv.meta().attributeHeadersForDim(1);
    var numberOfColumns = (_b = (_a = headers[0]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    var numberOfAttributes = descriptors.length;
    if (numberOfAttributes === 0) {
        return {
            groupingAttributes: [],
            leafColumns: [],
            rootColumns: [],
            allColumns: [],
        };
    }
    // for each attribute descriptor, there must be one array in the headers.
    invariant(descriptors.length === headers.length);
    var bottom = [];
    var _loop_1 = function (colIdx) {
        bottom.push({
            type: "scopeCol",
            id: "cg_" + colIdx,
            children: [],
            fullIndexPathToHere: [colIdx],
            header: headers[numberOfAttributes - 1][colIdx],
            headersToHere: headers.slice(0, numberOfAttributes - 1).map(function (attrHeaders) { return attrHeaders[colIdx]; }),
            attributeDescriptor: descriptors[numberOfAttributes - 1],
            descriptorsToHere: descriptors.slice(0, numberOfAttributes - 1),
        });
    };
    for (var colIdx = 0; colIdx < numberOfColumns; colIdx++) {
        _loop_1(colIdx);
    }
    // do the usual grouping logic with one tweak: do not process the last grouping level because code above
    // just created that.
    return groupColumns(bottom, descriptors, numberOfAttributes - 1);
}
function createColumnDescriptorsFromDataSeries(dv) {
    var _a;
    var leafColumns = dv
        .data()
        .series()
        .toArray()
        .map(function (series, idx) {
        return {
            type: "seriesCol",
            id: "c_" + idx,
            index: idx,
            seriesId: series.id,
            seriesDescriptor: series.descriptor,
            children: [],
            fullIndexPathToHere: [idx],
        };
    });
    var scopingAttributes = (_a = dv.data().series().scopingAttributes) !== null && _a !== void 0 ? _a : [];
    if (scopingAttributes.length === 0) {
        return {
            groupingAttributes: [],
            leafColumns: leafColumns,
            rootColumns: leafColumns,
            allColumns: leafColumns,
        };
    }
    return groupColumns(leafColumns, scopingAttributes);
}
function createRowDescriptors(dv) {
    return dv
        .data()
        .slices()
        .descriptors.filter(isAttributeDescriptor)
        .map(function (attributeDescriptor, idx) {
        var _a;
        return {
            type: "sliceCol",
            id: "r_" + idx,
            index: idx,
            attributeDescriptor: attributeDescriptor,
            fullIndexPathToHere: [idx],
            effectiveTotals: (_a = attributeDescriptor.attributeHeader.totalItems) !== null && _a !== void 0 ? _a : [],
        };
    });
}
function createColumnDescriptors(dv) {
    if (dv.meta().measureDescriptors().length === 0 && dv.meta().dimensions().length === 2) {
        /*
         * Columns for a table without any measures but with attributes in both dimensions cannot be created
         * using just the data access infrastructure. That is because data access operates with a concept of
         * data series that are calculated for some measure value. It does not cover the concept of having
         * 'table' without any actual computed data and only with attribute headers.
         *
         * We can perhaps enhance that infra one day if there is really a valid need. It is pretty much a corner
         * case.
         *
         * The table descriptor factory handles this case by extracting info from the second dimension on its own.
         */
        return createColumnDescriptorsWhenNoMeasures(dv);
    }
    return createColumnDescriptorsFromDataSeries(dv);
}
function createTableHeaders(dv) {
    var rows = createRowDescriptors(dv);
    var _a = createColumnDescriptors(dv), rootColumns = _a.rootColumns, leafColumns = _a.leafColumns, allColumns = _a.allColumns, groupingAttributes = _a.groupingAttributes;
    var idToDescriptor = {};
    rows.forEach(function (header) { return (idToDescriptor[header.id] = header); });
    allColumns.forEach(function (header) { return (idToDescriptor[header.id] = header); });
    return {
        sliceCols: rows,
        rootDataCols: rootColumns,
        leafDataCols: leafColumns,
        idToDescriptor: idToDescriptor,
        scopingAttributes: groupingAttributes,
    };
}
//
//
//
/**
 * Constructs a table header descriptors and ag-grid colDefs using result metadata contained in the provided DataViewFacade.
 *
 * This function is not intended for stand-alone usage. It used during construction of TableDescriptor.
 *
 * @param dv - data view facade
 * @internal
 */
export function createHeadersAndColDefs(dv) {
    var headers = createTableHeaders(dv);
    var colDefs = createColDefsFromTableDescriptor(headers, dv.meta().effectiveSortItems());
    return { headers: headers, colDefs: colDefs };
}
//# sourceMappingURL=tableDescriptorFactory.js.map