import { __assign, __rest } from "tslib";
// (C) 2007-2021 GoodData Corporation
import isEmpty from "lodash/isEmpty";
import { getGridIndex } from "./base/agUtils";
import ApiWrapper from "./base/agApiWrapper";
import { getScrollbarWidth } from "./utils";
import { ROW_ATTRIBUTE_COLUMN } from "./base/constants";
export function initializeStickyRow(gridApi) {
    gridApi.setPinnedTopRowData([{}]);
}
export function updateStickyRowPosition(gridApi, apiWrapper) {
    if (apiWrapper === void 0) { apiWrapper = ApiWrapper; }
    if (!gridApi) {
        return;
    }
    var headerHeight = apiWrapper.getHeaderHeight(gridApi);
    apiWrapper.setPinnedTopRowStyle(gridApi, "top", headerHeight + "px");
    apiWrapper.setPinnedTopRowStyle(gridApi, "padding-right", getScrollbarWidth() + "px");
}
export function stickyRowExists(gridApi, apiWrapper) {
    if (apiWrapper === void 0) { apiWrapper = ApiWrapper; }
    return !!apiWrapper.getPinnedTopRowElement(gridApi);
}
function shouldUpdate(currentScrollPosition, lastScrollPosition, rowHeight) {
    var initialUpdate = currentScrollPosition.top === 0;
    var currentRowIndex = getGridIndex(currentScrollPosition.top, rowHeight);
    var lastRowIndex = getGridIndex(lastScrollPosition.top, rowHeight);
    var differentRow = currentRowIndex !== lastRowIndex;
    // when scrolling horizontally update with the same cadence as rows as we don't know where the column borders are
    var horizontalBreakpointDistance = rowHeight;
    var currentHorizontalBreakpoint = getGridIndex(currentScrollPosition.left, horizontalBreakpointDistance);
    var lastHorizontalBreakpoint = getGridIndex(lastScrollPosition.left, horizontalBreakpointDistance);
    var differentHorizontalBreakpoint = currentHorizontalBreakpoint !== lastHorizontalBreakpoint;
    return initialUpdate || differentRow || differentHorizontalBreakpoint;
}
function areDataDifferent(previousData, currentData) {
    return (Object.keys(previousData).length !== Object.keys(currentData).length ||
        Object.keys(previousData).some(function (dataItemKey) {
            return previousData[dataItemKey] !== currentData[dataItemKey];
        }));
}
export function updateStickyRowContentClassesAndData(currentScrollPosition, lastScrollPosition, rowHeight, gridApi, groupingProvider, apiWrapper) {
    var _a, _b;
    if (!gridApi || !shouldUpdate(currentScrollPosition, lastScrollPosition, rowHeight)) {
        return;
    }
    var firstVisibleRowIndex = getGridIndex(currentScrollPosition.top, rowHeight);
    var firstVisibleRow = gridApi.getDisplayedRowAtIndex(firstVisibleRowIndex);
    var firstVisibleNodeData = (_a = firstVisibleRow === null || firstVisibleRow === void 0 ? void 0 : firstVisibleRow.data) !== null && _a !== void 0 ? _a : null;
    if (firstVisibleNodeData === null) {
        apiWrapper.removePinnedTopRowClass(gridApi, "gd-visible-sticky-row");
        return;
    }
    apiWrapper.addPinnedTopRowClass(gridApi, "gd-visible-sticky-row");
    var lastRowIndex = getGridIndex(lastScrollPosition.top, rowHeight);
    // TODO: consider obtaining row-col descriptors from tableDescriptor instead
    var attributeKeys = Object.keys(firstVisibleNodeData).filter(function (colId) {
        var colDef = gridApi.getColumnDef(colId);
        return colDef && colDef.type === ROW_ATTRIBUTE_COLUMN;
    });
    var stickyRowData = {};
    var headerItemMap = {};
    attributeKeys.forEach(function (columnId) {
        apiWrapper.removeCellClass(gridApi, columnId, lastRowIndex, "gd-cell-show-hidden");
        // the following value is the same as the current one
        if (groupingProvider.isRepeatedValue(columnId, firstVisibleRowIndex + 1)) {
            // set correct sticky row data
            stickyRowData[columnId] = firstVisibleNodeData[columnId];
            headerItemMap[columnId] = firstVisibleNodeData.headerItemMap[columnId];
        }
        else {
            // if the column has some groups
            if (groupingProvider.isColumnWithGrouping(columnId)) {
                // show the last cell of the group temporarily so it scrolls out of the viewport nicely
                var currentRowIndex = getGridIndex(currentScrollPosition.top, rowHeight);
                apiWrapper.addCellClass(gridApi, columnId, currentRowIndex, "gd-cell-show-hidden");
            }
        }
    });
    var previousRowData = (_b = gridApi.getPinnedTopRow(0)) === null || _b === void 0 ? void 0 : _b.data;
    var _ignoredHeaders = previousRowData.headerItemMap, _ignoredType = previousRowData.type, _ignoredStyle = previousRowData.subtotalStyle, previousData = __rest(previousRowData, ["headerItemMap", "type", "subtotalStyle"]);
    // set new rowData only if differen to avoid rerendering and flashing of the sticky row
    if (areDataDifferent(previousData, stickyRowData)) {
        var headerItemMapProp = isEmpty(headerItemMap) ? {} : { headerItemMap: headerItemMap };
        gridApi.setPinnedTopRowData([
            __assign(__assign({}, stickyRowData), headerItemMapProp),
        ]);
    }
}
//# sourceMappingURL=stickyRowHandler.js.map