import { __assign, __awaiter, __generator } from "tslib";
// (C) 2007-2021 GoodData Corporation
import invariant, { InvariantError } from "ts-invariant";
import omit from "lodash/omit";
import omitBy from "lodash/omitBy";
import chunk from "lodash/chunk";
import { isMeasureColumn } from "../base/agUtils";
import { DEFAULT_HEADER_FONT, DEFAULT_ROW_FONT, DEFAULT_SUBTOTAL_FONT, DEFAULT_TOTAL_FONT, HEADER_LABEL_CLASS, ROW_SUBTOTAL_CLASS, ROW_TOTAL_CLASS, VALUE_CLASS, } from "../base/constants";
import { isAbsoluteColumnWidth, isAllMeasureColumnWidthItem, isAttributeColumnWidthItem, isMeasureColumnWidthItem, isWeakMeasureColumnWidthItem, } from "../../columnWidths";
import { getMeasureCellFormattedValue } from "../cell/cellUtils";
import isEmpty from "lodash/isEmpty";
import { agColId, isScopeCol, isSeriesCol, isSliceCol, } from "../structure/tableDescriptorTypes";
import { createColumnLocator } from "../structure/colLocatorFactory";
import { colMeasureLocalId } from "../structure/colAccessors";
import { isSomeTotal } from "../data/dataSourceUtils";
export var MIN_WIDTH = 60;
export var MANUALLY_SIZED_MAX_WIDTH = 2000;
export var AUTO_SIZED_MAX_WIDTH = 500;
export var SORT_ICON_WIDTH = 12;
var COLUMN_RESIZE_CHUNK_SIZE = 50;
//
//
//
function isColumnWidthAuto(columnWidth) {
    return columnWidth.value === "auto";
}
var ResizedColumnsStore = /** @class */ (function () {
    function ResizedColumnsStore(tableDescriptor, manuallyResizedColumns, allMeasureColumnWidth, weakMeasuresColumnWidths) {
        var _this = this;
        if (manuallyResizedColumns === void 0) { manuallyResizedColumns = {}; }
        if (allMeasureColumnWidth === void 0) { allMeasureColumnWidth = null; }
        if (weakMeasuresColumnWidths === void 0) { weakMeasuresColumnWidths = {}; }
        this.getManuallyResizedColumn2 = function (col) {
            if (_this.manuallyResizedColumns[col.id]) {
                return _this.convertItem(_this.manuallyResizedColumns[col.id]);
            }
            var weakColumnWidth = _this.getMatchedWeakMeasuresColumnWidth(col);
            if (weakColumnWidth) {
                return _this.getWeakMeasureColumMapItem(weakColumnWidth);
            }
            if (isSeriesCol(col) && _this.isAllMeasureColumWidthUsed()) {
                return _this.getAllMeasureColumMapItem();
            }
        };
        this.getManuallyResizedColumn = function (item) {
            var colId = agColId(item);
            var col = _this.tableDescriptor.getCol(colId);
            return _this.getManuallyResizedColumn2(col);
        };
        this.isColumnManuallyResized = function (item) {
            return !!_this.getManuallyResizedColumn(item);
        };
        this.addToManuallyResizedColumn = function (column, allowGrowToFit) {
            if (allowGrowToFit === void 0) { allowGrowToFit = false; }
            _this.manuallyResizedColumns[agColId(column)] = {
                width: __assign({ value: column.getActualWidth() }, getAllowGrowToFitProp(allowGrowToFit)),
            };
            column.getColDef().suppressSizeToFit = !allowGrowToFit;
        };
        /**
         * Sets width for all column measures.
         *
         * Here Be Dragons 1: this also mutates input columns and sets supressSizeToFit prop to true.
         *
         * @param columnWidth - column width
         * @param allColumns - all columns in table
         */
        this.addAllMeasureColumn = function (columnWidth, allColumns) {
            _this.allMeasureColumnWidth = columnWidth;
            allColumns.forEach(function (col) {
                if (isMeasureColumn(col)) {
                    var colId = agColId(col);
                    if (_this.manuallyResizedColumns[colId]) {
                        _this.manuallyResizedColumns = omit(_this.manuallyResizedColumns, colId);
                    }
                    col.getColDef().suppressSizeToFit = true;
                }
            });
            _this.weakMeasuresColumnWidths = {};
        };
        this.addWeekMeasureColumn = function (column) {
            var width = column.getActualWidth();
            var measureHeaderLocalIdentifier = colMeasureLocalId(_this.tableDescriptor.getCol(column));
            if (measureHeaderLocalIdentifier) {
                _this.weakMeasuresColumnWidths[measureHeaderLocalIdentifier] = {
                    measureColumnWidthItem: {
                        width: {
                            value: width,
                        },
                        locator: {
                            measureLocatorItem: {
                                measureIdentifier: measureHeaderLocalIdentifier,
                            },
                        },
                    },
                };
                var shouldBeRemoved = function (resizedColumnItem) {
                    return resizedColumnItem.measureIdentifier === measureHeaderLocalIdentifier;
                };
                _this.manuallyResizedColumns = omitBy(_this.manuallyResizedColumns, shouldBeRemoved);
            }
        };
        this.removeAllMeasureColumns = function () {
            _this.allMeasureColumnWidth = null;
            var shouldBeRemoved = function (resizedColumnItem) {
                return isColumnWidthAuto(resizedColumnItem.width);
            };
            _this.manuallyResizedColumns = omitBy(_this.manuallyResizedColumns, shouldBeRemoved);
            _this.weakMeasuresColumnWidths = {};
        };
        this.removeWeakMeasureColumn = function (column) {
            var col = _this.tableDescriptor.getCol(agColId(column));
            var weakColumnWidth = _this.getMatchedWeakMeasuresColumnWidth(col);
            if (weakColumnWidth) {
                _this.weakMeasuresColumnWidths = omit(_this.weakMeasuresColumnWidths, weakColumnWidth.measureColumnWidthItem.locator.measureLocatorItem.measureIdentifier);
                var shouldBeRemoved = function (resizedColumnItem) {
                    return (isColumnWidthAuto(resizedColumnItem.width) &&
                        _this.isMatchingWeakWidth(resizedColumnItem, weakColumnWidth) &&
                        !_this.isAllMeasureColumWidthUsed());
                };
                _this.manuallyResizedColumns = omitBy(_this.manuallyResizedColumns, shouldBeRemoved);
            }
        };
        /**
         * Removes manual sizing setting from the store.
         *
         * Here Be Dragons 1: This method may be modifying the suppressSizeToFit setting
         * of the columns (e.g. mutating one of the inputs).
         *
         * Here Be Dragons 2: This method is adding what appears like 'dummy garage placeholder'
         * 'auto' widths when all measure width is used and then measure column is
         * removed. Not sure why.
         */
        this.removeFromManuallyResizedColumn = function (column) {
            var col = _this.tableDescriptor.getCol(agColId(column));
            var item = _this.manuallyResizedColumns[col.id];
            if (item) {
                _this.manuallyResizedColumns = omit(_this.manuallyResizedColumns, col.id);
                if (!_this.isAllMeasureColumWidthUsed() || !isMeasureColumn(column)) {
                    column.getColDef().suppressSizeToFit = false;
                }
            }
            if (isSeriesCol(col) &&
                (_this.isAllMeasureColumWidthUsed() || _this.getMatchedWeakMeasuresColumnWidth(col))) {
                // TODO INE: consider creating weakItem with width: "auto" when alt+DC over allMeasure
                _this.manuallyResizedColumns[col.id] = _this.getAutoSizeItem(column);
                column.getColDef().suppressSizeToFit = false;
            }
        };
        this.getColumnWidthsFromMap = function () {
            var result = getColumnWidthsFromMap(_this.manuallyResizedColumns, _this.tableDescriptor);
            if (_this.isAllMeasureColumWidthUsed()) {
                result.push(_this.getAllMeasureColumnWidth());
            }
            var weakColumnWidthItems = getWeakColumnWidthsFromMap(_this.weakMeasuresColumnWidths);
            return result.concat(weakColumnWidthItems);
        };
        this.updateColumnWidths = function (columnWidths) {
            var allMeasureWidthItem = _this.filterAllMeasureColumnWidthItem(columnWidths);
            if (allMeasureWidthItem && isAllMeasureColumnWidthItem(allMeasureWidthItem)) {
                var validatedAllMeasureColumnWidth = defaultWidthValidator(allMeasureWidthItem.measureColumnWidthItem.width);
                _this.allMeasureColumnWidth = isAbsoluteColumnWidth(validatedAllMeasureColumnWidth)
                    ? validatedAllMeasureColumnWidth.value
                    : null;
            }
            else {
                _this.allMeasureColumnWidth = null;
            }
            _this.weakMeasuresColumnWidths = _this.filterWeakColumnWidthItems(columnWidths);
            var columnWidthItems = _this.filterStrongColumnWidthItems(columnWidths);
            var columnWidthsByField = convertColumnWidthsToMap(_this.tableDescriptor, columnWidthItems);
            _this.manuallyResizedColumns = columnWidthsByField;
        };
        this.getMatchingColumnsByMeasure = function (targetColumn, allColumns) {
            var targetMeasureLocalIdentifier = colMeasureLocalId(_this.tableDescriptor.getCol(targetColumn));
            if (targetMeasureLocalIdentifier) {
                return allColumns.filter(function (col) {
                    var measureLocalIdentifier = colMeasureLocalId(_this.tableDescriptor.getCol(col));
                    return targetMeasureLocalIdentifier === measureLocalIdentifier;
                });
            }
            return [];
        };
        this.getMatchedWeakMeasuresColumnWidth = function (col) {
            if (!isSeriesCol(col)) {
                return;
            }
            var measureHeaderLocalIdentifier = col.seriesDescriptor.measureDescriptor.measureHeaderItem.localIdentifier;
            if (measureHeaderLocalIdentifier) {
                return _this.weakMeasuresColumnWidths[measureHeaderLocalIdentifier];
            }
        };
        this.filterWeakColumnWidthItems = function (columnWidths) {
            if (columnWidths) {
                var onlyWeakWidthItems = columnWidths.filter(isWeakMeasureColumnWidthItem);
                return onlyWeakWidthItems.reduce(function (map, weakWidthItem) {
                    var _a;
                    var validatedWidth = defaultWidthValidator(weakWidthItem.measureColumnWidthItem.width);
                    if (isAbsoluteColumnWidth(validatedWidth)) {
                        return __assign(__assign({}, map), (_a = {}, _a[weakWidthItem.measureColumnWidthItem.locator.measureLocatorItem
                            .measureIdentifier] = {
                            measureColumnWidthItem: __assign(__assign({}, weakWidthItem.measureColumnWidthItem), { width: __assign(__assign({}, weakWidthItem.measureColumnWidthItem.width), { value: validatedWidth.value }) }),
                        }, _a));
                    }
                    return map;
                }, {});
            }
            return {};
        };
        this.isAllMeasureColumWidthUsed = function () {
            return _this.allMeasureColumnWidth !== null;
        };
        this.getAutoSizeItem = function (column) {
            var measureHeaderLocalIdentifier = colMeasureLocalId(_this.tableDescriptor.getCol(column));
            var result = { width: { value: "auto" } };
            if (measureHeaderLocalIdentifier) {
                result.measureIdentifier = measureHeaderLocalIdentifier;
            }
            return result;
        };
        this.getAllMeasureColumMapItem = function () {
            return { width: _this.allMeasureColumnWidth };
        };
        this.getAllMeasureColumnWidth = function () {
            return {
                measureColumnWidthItem: {
                    width: {
                        value: _this.allMeasureColumnWidth,
                    },
                },
            };
        };
        this.tableDescriptor = tableDescriptor;
        this.manuallyResizedColumns = manuallyResizedColumns;
        this.allMeasureColumnWidth = allMeasureColumnWidth;
        this.weakMeasuresColumnWidths = weakMeasuresColumnWidths;
    }
    ResizedColumnsStore.prototype.filterAllMeasureColumnWidthItem = function (columnWidths) {
        if (columnWidths) {
            return columnWidths.filter(isAllMeasureColumnWidthItem)[0];
        }
    };
    ResizedColumnsStore.prototype.filterStrongColumnWidthItems = function (columnWidths) {
        if (columnWidths) {
            return columnWidths.filter(function (item) { return isAttributeColumnWidthItem(item) || isMeasureColumnWidthItem(item); });
        }
        return [];
    };
    ResizedColumnsStore.prototype.convertItem = function (item) {
        // columns with width.value = auto are hidden
        if (isAbsoluteColumnWidth(item.width)) {
            var width = item.width;
            return __assign({ width: width.value }, getAllowGrowToFitProp(width.allowGrowToFit));
        }
    };
    ResizedColumnsStore.prototype.getWeakMeasureColumMapItem = function (item) {
        return {
            width: item.measureColumnWidthItem.width.value,
        };
    };
    ResizedColumnsStore.prototype.isMatchingWeakWidth = function (item, weakColumnWidth) {
        return (item.measureIdentifier ===
            weakColumnWidth.measureColumnWidthItem.locator.measureLocatorItem.measureIdentifier);
    };
    return ResizedColumnsStore;
}());
export { ResizedColumnsStore };
//
//
//
export function convertColumnWidthsToMap(tableDescriptor, columnWidths, widthValidator) {
    if (widthValidator === void 0) { widthValidator = defaultWidthValidator; }
    if (!columnWidths) {
        return {};
    }
    var columnWidthsMap = {};
    columnWidths.forEach(function (columnWidth) {
        if (isAttributeColumnWidthItem(columnWidth)) {
            var _a = getAttributeColumnWidthItemFieldAndWidth(tableDescriptor, columnWidth), field = _a[0], width = _a[1];
            columnWidthsMap[field] = {
                width: widthValidator(width),
            };
        }
        if (isMeasureColumnWidthItem(columnWidth)) {
            var result = getMeasureColumnWidthItemFieldAndWidth(tableDescriptor, columnWidth);
            if (!result) {
                return;
            }
            var col = result[0], width = result[1];
            columnWidthsMap[col.id] = {
                width: widthValidator(width),
                measureIdentifier: colMeasureLocalId(col),
            };
        }
    });
    return columnWidthsMap;
}
function getAttributeColumnWidthItemFieldAndWidth(tableDescriptor, columnWidthItem) {
    var col = tableDescriptor.matchAttributeWidthItem(columnWidthItem);
    invariant(col, "Could not find column descriptor for width item for attribute \"" + columnWidthItem.attributeColumnWidthItem.attributeIdentifier + "\"");
    return [col.id, columnWidthItem.attributeColumnWidthItem.width];
}
function getMeasureColumnWidthItemFieldAndWidth(tableDescriptor, columnWidthItem) {
    var col = tableDescriptor.matchMeasureWidthItem(columnWidthItem);
    if (!col) {
        // it is a valid case that no column matches locators. data may change, elements are no longer there etc..
        return undefined;
    }
    return [col, columnWidthItem.measureColumnWidthItem.width];
}
function getSizeItemByColId(col, width) {
    if (isSliceCol(col)) {
        var attributeIdentifier = col.attributeDescriptor.attributeHeader.localIdentifier;
        if (isAbsoluteColumnWidth(width)) {
            return {
                attributeColumnWidthItem: {
                    width: width,
                    attributeIdentifier: attributeIdentifier,
                },
            };
        }
        else {
            throw new InvariantError("width value for attributeColumnWidthItem has to be number " + col.id);
        }
    }
    else if (isScopeCol(col) || isSeriesCol(col)) {
        return {
            measureColumnWidthItem: {
                width: width,
                locators: createColumnLocator(col),
            },
        };
    }
    throw new InvariantError("could not find header matching " + col.id);
}
export function getColumnWidthsFromMap(map, tableDescriptor) {
    return Object.keys(map).map(function (colId) {
        var width = map[colId].width;
        var col = tableDescriptor.getCol(colId);
        var sizeItem = getSizeItemByColId(col, width);
        invariant(sizeItem, "unable to find size item by filed " + colId);
        return sizeItem;
    });
}
export function getWeakColumnWidthsFromMap(map) {
    return Object.keys(map).map(function (measureIdentifier) {
        return map[measureIdentifier];
    });
}
function defaultWidthValidator(width) {
    if (isAbsoluteColumnWidth(width)) {
        return __assign(__assign({}, width), { value: Math.min(Math.max(width.value, MIN_WIDTH), MANUALLY_SIZED_MAX_WIDTH) });
    }
    return width;
}
/**
 * This function _mutates_ the incoming column defs according to the sizing rules.
 */
export function updateColumnDefinitionsWithWidths(tableDescriptor, resizedColumnsStore, autoResizedColumns, defaultColumnWidth, isGrowToFitEnabled, growToFittedColumns) {
    if (growToFittedColumns === void 0) { growToFittedColumns = {}; }
    var sliceCols = tableDescriptor.zippedSliceCols;
    var leaves = tableDescriptor.zippedLeaves;
    var allSizableCols = [];
    allSizableCols.push.apply(allSizableCols, sliceCols);
    allSizableCols.push.apply(allSizableCols, leaves);
    allSizableCols.forEach(function (_a) {
        var colDesc = _a[0], colDef = _a[1];
        var colId = colDesc.id;
        var manualSize = resizedColumnsStore.getManuallyResizedColumn2(colDesc);
        var autoResizeSize = autoResizedColumns[colId];
        colDef.maxWidth = MANUALLY_SIZED_MAX_WIDTH;
        if (manualSize) {
            colDef.width = manualSize.width;
            colDef.suppressSizeToFit = !manualSize.allowGrowToFit;
        }
        else {
            colDef.suppressSizeToFit = false;
            colDef.width = autoResizeSize ? autoResizeSize.width : defaultColumnWidth;
            if (isGrowToFitEnabled) {
                var growToFittedColumn = growToFittedColumns[colId];
                if (growToFittedColumn) {
                    colDef.width = growToFittedColumn.width;
                    if (growToFittedColumn.width > MANUALLY_SIZED_MAX_WIDTH) {
                        colDef.maxWidth = undefined;
                    }
                }
            }
        }
    });
}
export function syncSuppressSizeToFitOnColumns(resizedColumnsStore, columnApi) {
    if (!columnApi) {
        return;
    }
    var columns = columnApi.getAllColumns();
    columns === null || columns === void 0 ? void 0 : columns.forEach(function (col) {
        var resizedColumn = resizedColumnsStore.getManuallyResizedColumn(col);
        resizedColumn
            ? (col.getColDef().suppressSizeToFit = !resizedColumn.allowGrowToFit)
            : (col.getColDef().suppressSizeToFit = false);
    });
}
export function isColumnAutoResized(autoResizedColumns, resizedColumnId) {
    return Boolean(resizedColumnId && autoResizedColumns[resizedColumnId]);
}
export function resetColumnsWidthToDefault(columnApi, columns, resizedColumnsStore, autoResizedColumns, defaultWidth) {
    var resizeData = columns.reduce(function (acc, col) {
        var id = agColId(col);
        if (resizedColumnsStore.isColumnManuallyResized(col)) {
            var manuallyResizedColumn = resizedColumnsStore.getManuallyResizedColumn(col);
            if (manuallyResizedColumn) {
                acc.push({ key: col, newWidth: manuallyResizedColumn.width });
            }
        }
        else if (isColumnAutoResized(autoResizedColumns, id)) {
            acc.push({ key: col, newWidth: autoResizedColumns[id].width });
        }
        else {
            acc.push({ key: col, newWidth: defaultWidth });
        }
        return acc;
    }, []);
    columnApi.setColumnWidths(resizeData);
}
export function resizeAllMeasuresColumns(columnApi, resizedColumnsStore, column) {
    var columnWidth = column.getActualWidth();
    var allColumns = columnApi.getAllColumns();
    var resizeData = allColumns === null || allColumns === void 0 ? void 0 : allColumns.filter(isMeasureColumn).map(function (col) {
        return {
            key: col,
            newWidth: columnWidth,
        };
    });
    if (resizeData === null || resizeData === void 0 ? void 0 : resizeData.length) {
        columnApi.setColumnWidths(resizeData);
    }
    resizedColumnsStore.addAllMeasureColumn(columnWidth, allColumns !== null && allColumns !== void 0 ? allColumns : []);
}
export function resizeWeakMeasureColumns(tableDescriptor, columnApi, resizedColumnsStore, column) {
    var allColumns = columnApi.getAllColumns();
    resizedColumnsStore.addWeekMeasureColumn(column);
    allColumns === null || allColumns === void 0 ? void 0 : allColumns.forEach(function (col) {
        var colDesc = tableDescriptor.getCol(col);
        var weakColumnWidth = resizedColumnsStore.getMatchedWeakMeasuresColumnWidth(colDesc);
        if (isMeasureColumn(col) && weakColumnWidth) {
            columnApi.setColumnWidth(col, weakColumnWidth.measureColumnWidthItem.width.value);
            col.getColDef().suppressSizeToFit = true;
        }
    });
}
function getAllowGrowToFitProp(allowGrowToFit) {
    return allowGrowToFit ? { allowGrowToFit: allowGrowToFit } : {};
}
export function getMaxWidth(context, text, hasSort, maxWidth) {
    if (!text) {
        return;
    }
    var width = hasSort
        ? context.measureText(text).width + SORT_ICON_WIDTH
        : context.measureText(text).width;
    return maxWidth === undefined || width > maxWidth ? width : undefined;
}
export function getMaxWidthCached(context, text, maxWidth, widthsCache) {
    var cachedWidth = widthsCache.get(text);
    var width;
    if (cachedWidth === undefined) {
        width = context.measureText(text).width;
        widthsCache.set(text, width);
    }
    else {
        width = cachedWidth;
    }
    return maxWidth === undefined || width > maxWidth ? width : undefined;
}
function valueFormatter(text, col, separators) {
    return text !== undefined
        ? getMeasureCellFormattedValue(text, col.seriesDescriptor.measureFormat(), separators)
        : null;
}
function collectWidths(config, row, column, maxWidths) {
    var context = config.context;
    var col = config.tableDescriptor.getCol(column);
    if (col && context) {
        var text = row[col.id];
        var formattedText = isSeriesCol(col) && valueFormatter(text, col, config.separators);
        var textForCalculation = formattedText || text;
        var maxWidth = col.id ? maxWidths.get(col.id) : undefined;
        var possibleMaxWidth = void 0;
        if (config.cache) {
            possibleMaxWidth = getMaxWidthCached(context, textForCalculation, maxWidth, config.cache);
        }
        else {
            possibleMaxWidth = getMaxWidth(context, textForCalculation, false, maxWidth);
        }
        if (possibleMaxWidth) {
            maxWidths.set(col.id, possibleMaxWidth);
        }
    }
}
function getColWidth(maxWidth, padding) {
    var newWidth = maxWidth ? Math.ceil(maxWidth + padding) : 0;
    return Math.min(Math.max(MIN_WIDTH, newWidth), AUTO_SIZED_MAX_WIDTH);
}
export function getUpdatedColumnDefs(columns, maxWidths, padding) {
    return columns.reduce(function (updatedColumnDefs, column) {
        var colDef = column.getColDef();
        var colId = agColId(colDef);
        if (colId) {
            var maxWidth = maxWidths.get(colId);
            if (maxWidth) {
                updatedColumnDefs.push(__assign(__assign({}, colDef), { width: getColWidth(maxWidth, padding) }));
            }
        }
        return updatedColumnDefs;
    }, []);
}
var shouldStopCalculation = function (config, calculatedColumnsTotalWidth) {
    return config.columnAutoresizeOption === "viewport" &&
        config.clientWidth &&
        calculatedColumnsTotalWidth > config.clientWidth;
};
function calculateColumnWidths(config, resizedColumnsStore) {
    var context = config.context;
    var maxWidths = new Map();
    if (context) {
        var calculatedColumnsTotalWidth = 0;
        var _loop_1 = function (i) {
            var column = config.columns[i];
            var colDef = column.getColDef();
            var colId = agColId(colDef);
            var maxWidth = colId ? maxWidths.get(colId) : undefined;
            if (shouldStopCalculation(config, calculatedColumnsTotalWidth)) {
                return "break";
            }
            if (config.measureHeaders) {
                context.font = config.headerFont;
                var possibleMaxWidth = getMaxWidth(context, colDef.headerName, !!colDef.sort, maxWidth);
                if (colId && possibleMaxWidth) {
                    maxWidths.set(colId, possibleMaxWidth);
                }
            }
            config.rowData.forEach(function (row) {
                context.font = isSomeTotal(row.type) ? config.subtotalFont : config.rowFont;
                collectWidths(config, row, column, maxWidths);
            });
            config.totalData.forEach(function (row) {
                context.font = config.totalFont;
                collectWidths(config, row, column, maxWidths);
            });
            if (config.columnAutoresizeOption === "viewport") {
                var finalMaxWidth = colId ? maxWidths.get(colId) : undefined;
                var manuallyResizedColumn = resizedColumnsStore.getManuallyResizedColumn(column);
                // total width used for stopping calculation should prefer manual width over autowidth
                calculatedColumnsTotalWidth += manuallyResizedColumn
                    ? manuallyResizedColumn.width
                    : getColWidth(finalMaxWidth, config.padding);
            }
        };
        for (var i = 0; i < config.columns.length; i++) {
            var state_1 = _loop_1(i);
            if (state_1 === "break")
                break;
        }
    }
    return getUpdatedColumnDefs(config.columns, maxWidths, config.padding);
}
function getDisplayedRowData(gridApi) {
    var _a;
    var rowCount = gridApi.getDisplayedRowCount();
    var rowData = [];
    for (var index = 0; index < rowCount; index++) {
        var item = (_a = gridApi.getDisplayedRowAtIndex(index)) === null || _a === void 0 ? void 0 : _a.data;
        if (item) {
            rowData.push(item);
        }
    }
    return rowData;
}
function getDisplayedTotalData(gridApi) {
    var totalCount = gridApi.getPinnedBottomRowCount();
    var totalData = [];
    for (var index = 0; index < totalCount; index++) {
        var item = gridApi.getPinnedBottomRow(index).data;
        if (item) {
            totalData.push(item);
        }
    }
    return totalData;
}
function getTableFont(containerRef, className, defaultFont) {
    var element = containerRef.getElementsByClassName(className)[0];
    if (!element) {
        return defaultFont;
    }
    var _a = window.getComputedStyle(element), font = _a.font, fontWeight = _a.fontWeight, fontSize = _a.fontSize, fontFamily = _a.fontFamily;
    return isEmpty(font) ? fontWeight + " " + fontSize + " " + fontFamily : font;
}
function getTableFonts(containerRef) {
    /**
     * All fonts are gotten from first element with given class. Once we will have font different for each cell/header/row this will not work
     */
    var headerFont = getTableFont(containerRef, HEADER_LABEL_CLASS, DEFAULT_HEADER_FONT);
    var rowFont = getTableFont(containerRef, VALUE_CLASS, DEFAULT_ROW_FONT);
    var subtotalFont = getTableFont(containerRef, ROW_SUBTOTAL_CLASS, DEFAULT_SUBTOTAL_FONT);
    var totalFont = getTableFont(containerRef, ROW_TOTAL_CLASS, DEFAULT_TOTAL_FONT);
    return { headerFont: headerFont, rowFont: rowFont, subtotalFont: subtotalFont, totalFont: totalFont };
}
/**
 * Ag-Grid API set desired column sizes (it *mutates* pivot table columns data).
 */
export function autoresizeAllColumns(columnApi, autoResizedColumns) {
    return __awaiter(this, void 0, void 0, function () {
        var columns, chunks, _loop_2, _i, chunks_1, ch;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!columnApi) return [3 /*break*/, 4];
                    columns = columnApi.getPrimaryColumns();
                    chunks = chunk(columns, COLUMN_RESIZE_CHUNK_SIZE);
                    _loop_2 = function (ch) {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, new Promise(function (resolve) {
                                        setTimeout(function () {
                                            var resizeData = ch.reduce(function (acc, column) {
                                                var columnDef = column.getColDef();
                                                var colId = agColId(columnDef);
                                                var autoResizedColumn = autoResizedColumns[colId];
                                                if (colId && autoResizedColumn && autoResizedColumn.width) {
                                                    acc.push({ key: colId, newWidth: autoResizedColumn.width });
                                                }
                                                return acc;
                                            }, []);
                                            columnApi.setColumnWidths(resizeData);
                                            resolve();
                                        });
                                    })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    };
                    _i = 0, chunks_1 = chunks;
                    _a.label = 1;
                case 1:
                    if (!(_i < chunks_1.length)) return [3 /*break*/, 4];
                    ch = chunks_1[_i];
                    return [5 /*yield**/, _loop_2(ch)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    });
}
/**
 * Custom implementation of columns autoresizing according content: https://en.morzel.net/post/resizing-all-ag-gird-react-columns
 * Calculate the width of text for each grid cell and collect the minimum width needed for each of the gird columns.
 * Text width calculation is done efficiently with measureText method on Canvas.
 */
export function getAutoResizedColumns(tableDescriptor, gridApi, columnApi, execution, resizingConfig, resizedColumnsStore, options) {
    var _a;
    var containerRef = resizingConfig.containerRef, columnAutoresizeOption = resizingConfig.columnAutoresizeOption, clientWidth = resizingConfig.clientWidth;
    if (tableDescriptor && gridApi && columnApi && execution && containerRef) {
        var columns = (_a = columnApi.getPrimaryColumns()) !== null && _a !== void 0 ? _a : [];
        var _b = getTableFonts(containerRef), headerFont = _b.headerFont, rowFont = _b.rowFont, subtotalFont = _b.subtotalFont, totalFont = _b.totalFont;
        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");
        var rowData = getDisplayedRowData(gridApi);
        var totalData = getDisplayedTotalData(gridApi);
        var autoResizedColumns_1 = {};
        var updatedColumDefs = calculateColumnWidths({
            tableDescriptor: tableDescriptor,
            context: context,
            columns: columns,
            rowData: rowData,
            totalData: totalData,
            measureHeaders: options.measureHeaders,
            headerFont: headerFont,
            subtotalFont: subtotalFont,
            totalFont: totalFont,
            rowFont: rowFont,
            padding: options.padding,
            separators: options.separators,
            cache: new Map(),
            columnAutoresizeOption: columnAutoresizeOption,
            clientWidth: clientWidth,
        }, resizedColumnsStore);
        updatedColumDefs.forEach(function (columnDef) {
            if (agColId(columnDef) && columnDef.width !== undefined) {
                autoResizedColumns_1[agColId(columnDef)] = {
                    width: columnDef.width,
                };
            }
        });
        return autoResizedColumns_1;
    }
    return {};
}
export var isColumnAutoresizeEnabled = function (columnAutoresizeOption) {
    return columnAutoresizeOption === "viewport" || columnAutoresizeOption === "autoresizeAll";
};
//# sourceMappingURL=columnSizing.js.map