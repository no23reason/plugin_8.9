import { COLS_PER_PAGE } from "../base/constants";
import { GroupingProviderFactory } from "./rowGroupingProvider";
import { createAgGridPage } from "./rowFactory";
import { areTotalsChanged, isInvalidGetRowsRequest } from "./dataSourceUtils";
import isEqual from "lodash/isEqual";
import { attributeLocalId, bucketAttribute, defTotals, dimensionSetTotals, isAttributeSort, } from "@gooddata/sdk-model";
import { BucketNames, DataViewFacade } from "@gooddata/sdk-ui";
export function createAgGridDatasource(config, initialDv, gridApiProvider, intl) {
    return new AgGridDatasource(config, initialDv, gridApiProvider, intl);
}
var AgGridDatasource = /** @class */ (function () {
    function AgGridDatasource(config, initialDv, gridApiProvider, intl) {
        var _this = this;
        this.config = config;
        this.initialDv = initialDv;
        this.gridApiProvider = gridApiProvider;
        this.intl = intl;
        this.destroyed = false;
        this.createGroupingProvider = function (isSortedByFirst) {
            // grouping happens under two conditions: it is desired & the data is sorted by first column
            var shouldGroup = _this.config.getGroupRows() && isSortedByFirst;
            return GroupingProviderFactory.createProvider(shouldGroup);
        };
        this.resetGroupingProvider = function (sortModel) {
            if (sortModel === void 0) { sortModel = []; }
            var isSortedByFirst = isSortedByFirstAttribute(_this.config.tableDescriptor, sortModel);
            _this.grouping = _this.createGroupingProvider(isSortedByFirst);
        };
        this.onDestroy = function () {
            //
        };
        this.processData = function (dv, params) {
            var _a, _b;
            if (!dv) {
                return;
            }
            var successCallback = params.successCallback;
            var pageData = createAgGridPage(dv, _this.config.tableDescriptor, _this.intl);
            var rowData = pageData.rowData, rowTotals = pageData.rowTotals;
            var _c = dv.dataView, offset = _c.offset, count = _c.count, totalCount = _c.totalCount;
            var rowAttributeIds = _this.config.tableDescriptor.headers.sliceCols.map(function (header) { return header.id; });
            _this.grouping.processPage(rowData, offset[0], rowAttributeIds);
            // RAIL-1130: Backend returns incorrectly total: [1, N], when count: [0, N] and offset: [0, N]
            var lastRow = offset[0] === 0 && count[0] === 0 ? 0 : totalCount[0];
            _this.config.onPageLoaded(dv);
            successCallback(rowData, lastRow);
            /**
             * In version 25 ag-grid has much better logic that detects which cells need to be refreshed.
             * Unfortunately, this breaks row grouping because cells outside of the currently loaded page are not redrawn.
             * This is a problem, because the newly loaded page might change the grouping status of cells outside of the loaded page.
             * So we force a cell refresh to redraw all the cells with the up-to-date grouping CSS classes.
             * This basically reverts the improved logic in the new ag-grid and behaves very closely to ag-grid 22.
             */
            (_a = _this.gridApiProvider()) === null || _a === void 0 ? void 0 : _a.refreshCells({ force: true, suppressFlash: true });
            // set totals
            if (areTotalsChanged(_this.gridApiProvider(), rowTotals)) {
                (_b = _this.gridApiProvider()) === null || _b === void 0 ? void 0 : _b.setPinnedBottomRowData(rowTotals);
            }
        };
        this.transformResult = function (params, desiredSorts, desiredTotals) {
            var _a;
            var _b;
            var sortModel = params.sortModel;
            var result = _this.currentResult;
            var definition = result.definition;
            /*
             * This seems to trigger re-render of column/row headers, thus ensuring that sort indicators
             * are shown correctly.
             */
            (_b = _this.gridApiProvider()) === null || _b === void 0 ? void 0 : _b.refreshHeader();
            /*
             * Grouping provider is stateful, keeps accumulating info about pages; now that the pages
             * fundamentally change due to re-exec, the grouping provider must be reset as well.
             */
            _this.resetGroupingProvider(sortModel);
            var transformedExecution = (_a = result
                .transform())
                .withSorting.apply(_a, desiredSorts).withDimensions(dimensionSetTotals(definition.dimensions[0], desiredTotals), definition.dimensions[1]);
            _this.config.onExecutionTransformed(transformedExecution);
            _this.driveExecutionAndUpdateDatasource(transformedExecution, params);
        };
        this.driveExecutionAndUpdateDatasource = function (execution, params) {
            var startRow = params.startRow, endRow = params.endRow, failCallback = params.failCallback;
            execution
                .execute()
                .then(function (newResult) {
                _this.currentResult = newResult;
                newResult
                    .readWindow([startRow, 0], [endRow - startRow, COLS_PER_PAGE])
                    .then(function (data) {
                    var _a;
                    var dataView = _this.config.dataViewTransform(data);
                    var dv = DataViewFacade.for(dataView);
                    (_a = _this.gridApiProvider()) === null || _a === void 0 ? void 0 : _a.setInfiniteRowCount(dataView.totalCount[0]);
                    _this.currentSorts = dv.meta().effectiveSortItems();
                    // Table descriptors contain information about effective totals (e.g. totals set for the
                    // table right now). After redrive of execution to change sorts/totals, code must make
                    // sure that the new settings are reflected in the table descriptor.
                    _this.config.tableDescriptor.updateEffectiveTotals(dv);
                    _this.processData(dv, params);
                })
                    .catch(function (err) {
                    _this.config.onTransformedExecutionFailed();
                    // eslint-disable-next-line no-console
                    console.error("Error while doing execution to obtain data view", err);
                    failCallback();
                });
            })
                .catch(function (err) {
                _this.config.onTransformedExecutionFailed();
                // eslint-disable-next-line no-console
                console.error("Error while doing execution to obtain transformed results", err);
                failCallback();
            });
        };
        this.destroy = function () {
            if (_this.destroyed) {
                return;
            }
            _this.destroyed = true;
            _this.onDestroy();
        };
        this.getRows = function (params) {
            var startRow = params.startRow, endRow = params.endRow, failCallback = params.failCallback, sortModel = params.sortModel;
            if (isInvalidGetRowsRequest(startRow, _this.gridApiProvider())) {
                failCallback();
                return;
            }
            var result = _this.currentResult;
            var definition = result.definition;
            var desiredSorts = _this.config.tableDescriptor.createSortItems(sortModel !== null && sortModel !== void 0 ? sortModel : [], result.definition.sortBy);
            var currentTotals = defTotals(definition, 0);
            var desiredTotals = _this.config.getColumnTotals();
            if (!isEqual(_this.currentSorts, desiredSorts) || !isEqual(currentTotals, desiredTotals)) {
                _this.transformResult(params, desiredSorts, desiredTotals);
            }
            else if (!startRow && result.definition === _this.initialDv.definition) {
                /*
                 * > Loading first page of data
                 *
                 * AND
                 *
                 * > Exec definition of the effective result to get data from is same as the exec definition of the
                 * initial data view that was used to construct the table and its data source.
                 *
                 * ===
                 *
                 * can reuse the initial data view
                 *
                 */
                _this.processData(_this.initialDv, params);
            }
            else {
                result
                    .readWindow([startRow, 0], [endRow - startRow, COLS_PER_PAGE])
                    .then(function (data) {
                    var dataView = _this.config.dataViewTransform(data);
                    _this.processData(DataViewFacade.for(dataView), params);
                })
                    .catch(function (err) {
                    // eslint-disable-next-line no-console
                    console.error("Error while doing execution to obtain data view", err);
                    failCallback();
                });
            }
        };
        this.getGroupingProvider = function () {
            return _this.grouping;
        };
        this.currentResult = initialDv.result();
        this.currentSorts = initialDv.meta().effectiveSortItems();
        // we do not have a sortModel yet so we need to check the dataView itself if the sorting makes sense
        var isInitialDvSortedByFirstAttribute = isDataViewSortedByFirstAttribute(initialDv);
        this.grouping = this.createGroupingProvider(isInitialDvSortedByFirstAttribute);
    }
    return AgGridDatasource;
}());
export { AgGridDatasource };
function isSortedByFirstAttribute(tableDescriptor, sortingCols) {
    if (!sortingCols.length) {
        // this is somewhat dangerous assumption: no explicit sort == sorted by first col
        //  (bear backend behaves thusly)
        return true;
    }
    if (sortingCols.length > 1) {
        return false;
    }
    return tableDescriptor.isFirstCol(sortingCols[0].colId);
}
function isDataViewSortedByFirstAttribute(dv) {
    var sortBy = dv.definition.sortBy;
    if (!sortBy || !sortBy.length) {
        // this is somewhat dangerous assumption: no explicit sort == sorted by first col
        //  (bear backend behaves thusly)
        return true;
    }
    if (sortBy.length > 1) {
        return false;
    }
    var firstSortBy = sortBy[0];
    if (!isAttributeSort(firstSortBy)) {
        return false;
    }
    var attributeBucket = dv.def().bucket(BucketNames.ATTRIBUTE);
    if (!attributeBucket) {
        return false;
    }
    var firstAttribute = bucketAttribute(attributeBucket);
    if (!firstAttribute) {
        return false;
    }
    return firstSortBy.attributeSortItem.attributeIdentifier === attributeLocalId(firstAttribute);
}
//# sourceMappingURL=dataSource.js.map