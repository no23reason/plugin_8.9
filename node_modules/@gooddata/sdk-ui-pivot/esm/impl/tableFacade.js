import { __awaiter, __generator } from "tslib";
// (C) 2007-2021 GoodData Corporation
import { TableDescriptor } from "./structure/tableDescriptor";
import { createExportFunction, DataViewFacade, } from "@gooddata/sdk-ui";
import { AUTO_SIZED_MAX_WIDTH, autoresizeAllColumns, getAutoResizedColumns, isColumnAutoResized, MANUALLY_SIZED_MAX_WIDTH, resetColumnsWidthToDefault, resizeAllMeasuresColumns, ResizedColumnsStore, resizeWeakMeasureColumns, syncSuppressSizeToFitOnColumns, updateColumnDefinitionsWithWidths, isColumnAutoresizeEnabled, } from "./resizing/columnSizing";
import { UIClick } from "../columnWidths";
import { createAgGridDatasource } from "./data/dataSource";
import { defFingerprint } from "@gooddata/sdk-model";
import { invariant } from "ts-invariant";
import { fixEmptyHeaderItems } from "@gooddata/sdk-ui-vis-commons";
import { setColumnMaxWidth, setColumnMaxWidthIf } from "./base/agColumnWrapper";
import { agColIds, isMeasureColumn } from "./base/agUtils";
import { agColId } from "./structure/tableDescriptorTypes";
import { sleep } from "./utils";
import { DEFAULT_AUTOSIZE_PADDING, DEFAULT_ROW_HEIGHT } from "./base/constants";
import { getAvailableDrillTargets } from "./drilling/drillTargets";
import sumBy from "lodash/sumBy";
import ApiWrapper from "./base/agApiWrapper";
import { initializeStickyRow, stickyRowExists, updateStickyRowContentClassesAndData, updateStickyRowPosition, } from "./stickyRowHandler";
var HEADER_CELL_BORDER = 1;
var COLUMN_RESIZE_TIMEOUT = 300;
/**
 * This class is a collection of higher-level operations with the table. On top of that the facade keeps track
 * of the state of the data rendered by the table (currentResult, visibleData etc).
 *
 * The facade uses different other sub-modules to get the job done. Most notable are:
 *
 * -  table descriptor
 * -  ag-grid data source
 * -  column resizing store & functions related to it
 * -  sticky row handler and the related ag-grid API Wrapper
 *
 * TODO: This class requires further refactoring. The state maintained by the table is problematic. It needs
 *  to belong to something else. The data related stuff should likely go into the data source and for the
 *  resizing we need some additional higher-level component on top of the resized column store & friends.
 */
var TableFacade = /** @class */ (function () {
    function TableFacade(result, dataView, tableMethods, props) {
        var _this = this;
        this.destroyed = false;
        this.finishInitialization = function (gridApi, columnApi) {
            invariant(_this.gridApi === undefined);
            invariant(_this.agGridDataSource);
            _this.gridApi = gridApi;
            _this.columnApi = columnApi;
            _this.gridApi.setDatasource(_this.agGridDataSource);
        };
        this.refreshData = function () {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return;
            }
            // make ag-grid refresh data
            // see: https://www.ag-grid.com/javascript-grid-infinite-scrolling/#changing-the-datasource
            gridApi.setDatasource(_this.agGridDataSource);
        };
        /**
         * Destroys the facade; this must do any essential cleanup of the resources and state so as to ensure
         * that any asynchronous processing that may be connected to this facade will be muted.
         *
         * This is essential to prevent this error from happening: https://github.com/ag-grid/ag-grid/issues/3334
         *
         * The error (while manifesting in ag-grid) is related to operating with a gridApi that is not connected
         * to a currently rendered table. Various errors occur in ag-grid but those are all symptoms of working
         * with a zombie.
         *
         * As is, destroy will clean up all references to gridApi & column api, so that no code that already relies
         * on their existence gets short-circuited.
         */
        this.destroy = function () {
            // in spirit of cleaning up the table & the old state, facade should call destroy() on
            // the gridApi. The table never did that so i'm not going to temp the 'luck' at the moment
            _this.gridApi = undefined;
            _this.columnApi = undefined;
            _this.destroyed = true;
        };
        this.isFullyInitialized = function () {
            return _this.gridApi !== undefined;
        };
        /**
         * Tests whether the table's data source is currently undergoing transformation & data loading. This will
         * be return true when for instance sorts or totals change and the table's data source drives new execution
         * with the updated sorts or totals.
         */
        this.isTransforming = function () {
            return _this.transformedExecution !== undefined;
        };
        this.clearFittedColumns = function () {
            _this.growToFittedColumns = {};
        };
        /**
         * All functions in the entire table should use this gridApiGuard to access an instance of ag-grid's GridApi.
         *
         * If the table facade is destroyed, the guard always returns false and emits a debug log. Otherwise it just
         * returns the current value of gridApi field.
         */
        this.gridApiGuard = function () {
            if (!_this.destroyed) {
                return _this.gridApi;
            }
            // eslint-disable-next-line no-console
            console.debug("Attempting to obtain gridApi for a destructed table.");
            return undefined;
        };
        this.updateColumnWidths = function (resizingConfig) {
            _this.resizedColumnsStore.updateColumnWidths(resizingConfig.widths);
            updateColumnDefinitionsWithWidths(_this.tableDescriptor, _this.resizedColumnsStore, _this.autoResizedColumns, resizingConfig.defaultWidth, resizingConfig.growToFit, _this.growToFittedColumns);
        };
        this.createDataSource = function (tableMethods) {
            _this.onPageLoadedCallback = tableMethods.onPageLoaded;
            return createAgGridDatasource({
                tableDescriptor: _this.tableDescriptor,
                getGroupRows: tableMethods.getGroupRows,
                getColumnTotals: tableMethods.getColumnTotals,
                onPageLoaded: _this.onPageLoaded,
                onExecutionTransformed: _this.onExecutionTransformed,
                onTransformedExecutionFailed: _this.onTransformedExecutionFailed,
                dataViewTransform: function (dataView) {
                    _this.fixEmptyHeaders(dataView);
                    return dataView;
                },
            }, _this.visibleData, _this.gridApiGuard, _this.intl);
        };
        this.onExecutionTransformed = function (newExecution) {
            var _a;
            // eslint-disable-next-line no-console
            console.debug("onExecutionTransformed", newExecution.definition);
            _this.transformedExecution = newExecution;
            (_a = _this.onExecutionTransformedCallback) === null || _a === void 0 ? void 0 : _a.call(_this, newExecution);
        };
        this.onTransformedExecutionFailed = function () {
            _this.transformedExecution = undefined;
        };
        this.onPageLoaded = function (dv) {
            var _a;
            var oldResult = _this.currentResult;
            _this.transformedExecution = undefined;
            _this.currentResult = dv.result();
            _this.visibleData = dv;
            _this.currentFingerprint = defFingerprint(_this.currentResult.definition);
            (_a = _this.onPageLoadedCallback) === null || _a === void 0 ? void 0 : _a.call(_this, dv, !(oldResult === null || oldResult === void 0 ? void 0 : oldResult.equals(_this.currentResult)));
        };
        this.createExportFunction = function (title) {
            return createExportFunction(_this.currentResult, title);
        };
        this.getAvailableDrillTargets = function () {
            return getAvailableDrillTargets(_this.visibleData);
        };
        this.refreshHeader = function () {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return;
            }
            gridApi.refreshHeader();
        };
        this.growToFit = function (resizingConfig) {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return;
            }
            invariant(_this.columnApi);
            var columns = _this.columnApi.getAllColumns();
            invariant(columns);
            _this.resetColumnsWidthToDefault(resizingConfig, columns);
            _this.clearFittedColumns();
            var widths = columns.map(function (column) { return column.getActualWidth(); });
            var sumOfWidths = widths.reduce(function (a, b) { return a + b; }, 0);
            if (sumOfWidths < resizingConfig.clientWidth) {
                var columnIds = agColIds(columns);
                setColumnMaxWidth(_this.columnApi, columnIds, undefined);
                _this.sizeColumnsToFitWithoutColumnReset(resizingConfig);
                setColumnMaxWidthIf(_this.columnApi, columnIds, MANUALLY_SIZED_MAX_WIDTH, function (column) { return column.getActualWidth() <= MANUALLY_SIZED_MAX_WIDTH; });
                _this.setFittedColumns();
            }
        };
        this.fixEmptyHeaders = function (dataView) {
            fixEmptyHeaderItems(dataView, "(" + _this.intl.formatMessage({ id: "visualization.emptyValue" }) + ")");
        };
        this.setFittedColumns = function () {
            invariant(_this.columnApi);
            var columns = _this.columnApi.getAllColumns();
            invariant(columns);
            columns.forEach(function (col) {
                var id = agColId(col);
                _this.growToFittedColumns[id] = {
                    width: col.getActualWidth(),
                };
            });
        };
        this.resetColumnsWidthToDefault = function (resizingConfig, columns) {
            invariant(_this.columnApi);
            resetColumnsWidthToDefault(_this.columnApi, columns, _this.resizedColumnsStore, _this.autoResizedColumns, resizingConfig.defaultWidth);
        };
        this.applyColumnSizes = function (resizingConfig) {
            invariant(_this.columnApi);
            _this.resizedColumnsStore.updateColumnWidths(resizingConfig.widths);
            syncSuppressSizeToFitOnColumns(_this.resizedColumnsStore, _this.columnApi);
            if (resizingConfig.growToFit) {
                _this.growToFit(resizingConfig); // calls resetColumnsWidthToDefault internally too
            }
            else {
                var columns = _this.columnApi.getAllColumns();
                invariant(columns);
                _this.resetColumnsWidthToDefault(resizingConfig, columns);
            }
        };
        this.autoresizeColumns = function (resizingConfig, force) {
            if (force === void 0) { force = false; }
            return __awaiter(_this, void 0, void 0, function () {
                var gridApi, alreadyResized, columns;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            gridApi = this.gridApiGuard();
                            if (!gridApi) {
                                return [2 /*return*/, false];
                            }
                            invariant(this.columnApi);
                            if (this.resizing && !force) {
                                return [2 /*return*/, false];
                            }
                            alreadyResized = function () { return _this.resizing; };
                            if (!(this.isPivotTableReady() && (!alreadyResized() || (alreadyResized() && force)))) return [3 /*break*/, 2];
                            this.resizing = true;
                            // we need to know autosize width for each column, even manually resized ones, to support removal of columnWidth def from props
                            return [4 /*yield*/, this.autoresizeAllColumns(resizingConfig)];
                        case 1:
                            // we need to know autosize width for each column, even manually resized ones, to support removal of columnWidth def from props
                            _a.sent();
                            // after that we need to reset manually resized columns back to its manually set width by growToFit or by helper. See UT resetColumnsWidthToDefault for width priorities
                            if (resizingConfig.growToFit) {
                                this.growToFit(resizingConfig);
                            }
                            else if (isColumnAutoresizeEnabled(resizingConfig.columnAutoresizeOption) &&
                                this.shouldPerformAutoresize()) {
                                columns = this.columnApi.getAllColumns();
                                invariant(columns);
                                this.resetColumnsWidthToDefault(resizingConfig, columns);
                            }
                            this.resizing = false;
                            return [2 /*return*/, true];
                        case 2: return [2 /*return*/, false];
                    }
                });
            });
        };
        this.autoresizeAllColumns = function (resizingConfig) { return __awaiter(_this, void 0, void 0, function () {
            var gridApi;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gridApi = this.gridApiGuard();
                        if (!gridApi) {
                            return [2 /*return*/];
                        }
                        invariant(this.columnApi);
                        if (!this.shouldPerformAutoresize() ||
                            !isColumnAutoresizeEnabled(resizingConfig.columnAutoresizeOption)) {
                            return [2 /*return*/, Promise.resolve()];
                        }
                        return [4 /*yield*/, sleep(COLUMN_RESIZE_TIMEOUT)];
                    case 1:
                        _a.sent();
                        /*
                         * Ensures correct autoResizeColumns
                         */
                        this.updateAutoResizedColumns(resizingConfig);
                        return [4 /*yield*/, autoresizeAllColumns(this.columnApi, this.autoResizedColumns)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
        this.updateAutoResizedColumns = function (resizingConfig) {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return;
            }
            invariant(_this.columnApi);
            invariant(resizingConfig.containerRef);
            _this.autoResizedColumns = getAutoResizedColumns(_this.tableDescriptor, gridApi, _this.columnApi, _this.currentResult, resizingConfig, _this.resizedColumnsStore, {
                measureHeaders: true,
                padding: 2 * DEFAULT_AUTOSIZE_PADDING + HEADER_CELL_BORDER,
                separators: resizingConfig.separators,
            });
        };
        this.isPivotTableReady = function () {
            if (!_this.gridApi || _this.destroyed) {
                return false;
            }
            var api = _this.gridApi;
            var noRowHeadersOrRows = function () {
                return Boolean(_this.visibleData.rawData().isEmpty() && _this.visibleData.meta().hasNoHeadersInDim(0));
            };
            var dataRendered = function () {
                return noRowHeadersOrRows() || api.getRenderedNodes().length > 0;
            };
            var tablePagesLoaded = function () {
                var pages = api.getCacheBlockState();
                return (pages &&
                    Object.keys(pages).every(function (pageId) {
                        return pages[pageId].pageStatus === "loaded" || pages[pageId].pageStatus === "failed";
                    }));
            };
            return tablePagesLoaded() && dataRendered();
        };
        this.shouldPerformAutoresize = function () {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return false;
            }
            var horizontalPixelRange = gridApi.getHorizontalPixelRange();
            var verticalPixelRange = gridApi.getVerticalPixelRange();
            return horizontalPixelRange.left === 0 && verticalPixelRange.top === 0;
        };
        this.isColumnAutoResized = function (resizedColumnId) {
            return isColumnAutoResized(_this.autoResizedColumns, resizedColumnId);
        };
        this.resetResizedColumn = function (column) { return __awaiter(_this, void 0, void 0, function () {
            var id;
            var _a;
            return __generator(this, function (_b) {
                if (!this.tableDescriptor) {
                    return [2 /*return*/];
                }
                id = agColId(column);
                if (this.resizedColumnsStore.isColumnManuallyResized(column)) {
                    this.resizedColumnsStore.removeFromManuallyResizedColumn(column);
                }
                column.getColDef().suppressSizeToFit = false;
                if (this.isColumnAutoResized(id)) {
                    (_a = this.columnApi) === null || _a === void 0 ? void 0 : _a.setColumnWidth(column, this.autoResizedColumns[id].width);
                    return [2 /*return*/];
                }
                this.autoresizeColumnsByColumnId(this.columnApi, agColIds([column]));
                this.resizedColumnsStore.addToManuallyResizedColumn(column, true);
                return [2 /*return*/];
            });
        }); };
        this.autoresizeColumnsByColumnId = function (columnApi, columnIds) {
            setColumnMaxWidth(columnApi, columnIds, AUTO_SIZED_MAX_WIDTH);
            columnApi.autoSizeColumns(columnIds);
            setColumnMaxWidth(columnApi, columnIds, MANUALLY_SIZED_MAX_WIDTH);
        };
        this.onColumnsManualReset = function (resizingConfig, columns) { return __awaiter(_this, void 0, void 0, function () {
            var gridApi, columnsToReset, _i, columnsToReset_1, column;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gridApi = this.gridApiGuard();
                        if (!gridApi) {
                            return [2 /*return*/];
                        }
                        invariant(this.columnApi);
                        columnsToReset = columns;
                        /*
                         * Ensures that all columns have the correct width to use during column reset
                         * resetResizedColumn uses updateAutoResizedColumns to properly reset columns
                         */
                        if (!Object.keys(this.autoResizedColumns).length) {
                            this.updateAutoResizedColumns(resizingConfig);
                        }
                        if (this.isAllMeasureResizeOperation(resizingConfig, columns)) {
                            this.resizedColumnsStore.removeAllMeasureColumns();
                            columnsToReset = this.getAllMeasureColumns();
                        }
                        if (this.isWeakMeasureResizeOperation(resizingConfig, columns)) {
                            columnsToReset = this.resizedColumnsStore.getMatchingColumnsByMeasure(columns[0], this.getAllMeasureColumns());
                            this.resizedColumnsStore.removeWeakMeasureColumn(columns[0]);
                        }
                        _i = 0, columnsToReset_1 = columnsToReset;
                        _a.label = 1;
                    case 1:
                        if (!(_i < columnsToReset_1.length)) return [3 /*break*/, 4];
                        column = columnsToReset_1[_i];
                        return [4 /*yield*/, this.resetResizedColumn(column)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        this.afterOnResizeColumns(resizingConfig);
                        return [2 /*return*/];
                }
            });
        }); };
        this.getAllMeasureColumns = function () {
            invariant(_this.columnApi);
            var columns = _this.columnApi.getAllColumns();
            invariant(columns);
            return columns.filter(function (col) { return isMeasureColumn(col); });
        };
        this.onColumnsManualResized = function (resizingConfig, columns) {
            if (_this.isAllMeasureResizeOperation(resizingConfig, columns)) {
                resizeAllMeasuresColumns(_this.columnApi, _this.resizedColumnsStore, columns[0]);
            }
            else if (_this.isWeakMeasureResizeOperation(resizingConfig, columns)) {
                resizeWeakMeasureColumns(_this.tableDescriptor, _this.columnApi, _this.resizedColumnsStore, columns[0]);
            }
            else {
                columns.forEach(function (column) {
                    _this.resizedColumnsStore.addToManuallyResizedColumn(column);
                });
            }
            _this.afterOnResizeColumns(resizingConfig);
        };
        this.onManualColumnResize = function (resizingConfig, columns) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.numberOfColumnResizedCalls++;
                        return [4 /*yield*/, sleep(COLUMN_RESIZE_TIMEOUT)];
                    case 1:
                        _a.sent();
                        if (!(this.numberOfColumnResizedCalls === UIClick.DOUBLE_CLICK)) return [3 /*break*/, 3];
                        this.numberOfColumnResizedCalls = 0;
                        return [4 /*yield*/, this.onColumnsManualReset(resizingConfig, columns)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        if (this.numberOfColumnResizedCalls === UIClick.CLICK) {
                            this.numberOfColumnResizedCalls = 0;
                            this.onColumnsManualResized(resizingConfig, columns);
                        }
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        }); };
        this.afterOnResizeColumns = function (resizingConfig) {
            var _a;
            if (resizingConfig.growToFit) {
                _this.growToFit(resizingConfig);
            }
            var columnWidths = _this.resizedColumnsStore.getColumnWidthsFromMap();
            (_a = resizingConfig.onColumnResized) === null || _a === void 0 ? void 0 : _a.call(resizingConfig, columnWidths);
        };
        this.getGroupingProvider = function () {
            invariant(_this.agGridDataSource);
            return _this.agGridDataSource.getGroupingProvider();
        };
        this.createSortItems = function (columns) {
            return _this.tableDescriptor.createSortItems(columns, _this.currentResult.definition.sortBy);
        };
        this.getTotalBodyHeight = function () {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return 0;
            }
            var dv = _this.visibleData;
            var aggregationCount = sumBy(dv.rawData().totals(), function (total) { return total.length; });
            var rowCount = dv.rawData().firstDimSize();
            var headerHeight = ApiWrapper.getHeaderHeight(gridApi);
            // add small room for error to avoid scrollbars that scroll one, two pixels
            // increased in order to resolve issue BB-1509
            var leeway = 2;
            var bodyHeight = rowCount * DEFAULT_ROW_HEIGHT + leeway;
            var footerHeight = aggregationCount * DEFAULT_ROW_HEIGHT;
            return headerHeight + bodyHeight + footerHeight;
        };
        this.updateStickyRowContent = function (stickyCtx) {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return;
            }
            updateStickyRowContentClassesAndData(stickyCtx.scrollPosition, stickyCtx.lastScrollPosition, DEFAULT_ROW_HEIGHT, gridApi, _this.getGroupingProvider(), ApiWrapper);
        };
        this.updateStickyRowPosition = function () {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return;
            }
            updateStickyRowPosition(gridApi);
        };
        /**
         * Initializes a single empty pinned top row in ag-grid. This is where table code can push sticky row data
         * as user keeps scrolling the table.
         */
        this.initializeStickyRow = function () {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return;
            }
            initializeStickyRow(gridApi);
        };
        /**
         * Clears the pinned top row in ag-grid.
         */
        this.clearStickyRow = function () {
            //
            _this.initializeStickyRow();
        };
        this.stickyRowExists = function () {
            var gridApi = _this.gridApiGuard();
            if (!gridApi) {
                return false;
            }
            return stickyRowExists(gridApi);
        };
        this.getRowCount = function () {
            return _this.visibleData.rawData().firstDimSize();
        };
        this.getDrillDataContext = function () {
            return _this.visibleData;
        };
        this.isResizing = function () {
            return _this.resizing;
        };
        this.setTooltipFields = function () {
            invariant(_this.columnApi);
            var columns = _this.columnApi.getAllColumns();
            invariant(columns);
            columns.forEach(function (col) {
                var colDef = col.getColDef();
                colDef.tooltipField = colDef.field;
            });
        };
        this.intl = props.intl;
        this.currentResult = result;
        this.fixEmptyHeaders(dataView);
        this.visibleData = DataViewFacade.for(dataView);
        this.currentFingerprint = defFingerprint(this.currentResult.definition);
        this.tableDescriptor = TableDescriptor.for(this.visibleData);
        this.autoResizedColumns = {};
        this.growToFittedColumns = {};
        this.resizing = false;
        this.resizedColumnsStore = new ResizedColumnsStore(this.tableDescriptor);
        this.numberOfColumnResizedCalls = 0;
        this.agGridDataSource = this.createDataSource(tableMethods);
        this.onExecutionTransformedCallback = tableMethods.onExecutionTransformed;
        this.updateColumnWidths(tableMethods.getResizingConfig());
        this.originalExecution = props.execution;
    }
    TableFacade.prototype.isAllMeasureResizeOperation = function (resizingConfig, columns) {
        return resizingConfig.isMetaOrCtrlKeyPressed && columns.length === 1 && isMeasureColumn(columns[0]);
    };
    TableFacade.prototype.isWeakMeasureResizeOperation = function (resizingConfig, columns) {
        return resizingConfig.isAltKeyPressed && columns.length === 1 && isMeasureColumn(columns[0]);
    };
    /**
     * Do what ag-grid used to do in sizeColumnsToFit in version 22.
     *
     * In ag-grid 25 the sizeColumnsToFit unfortunately calls resetWidth on all columns at the start, which in effect
     * resets all of our autosizing values and makes the growToFit unusable with defaultWidth: "autoresizeAll".
     * There is no parameter or other way to opt-out of this newly added reset.
     *
     * So we use the same logic as ag-grid 22 did in order to make both growToFit and autoresizeAll work together.
     * Ideally, this would not be needed and we should devise some other way of working around the fact
     * that ag-grid 25 resets column widths here.
     *
     * The comments in code are original from the ag-grid 22 code base.
     */
    TableFacade.prototype.sizeColumnsToFitWithoutColumnReset = function (resizingConfig) {
        var _a;
        invariant(this.columnApi);
        var source = "sizeColumnsToFit";
        var gridWidth = resizingConfig.clientWidth;
        // avoid divide by zero
        var allDisplayedColumns = (_a = this.columnApi) === null || _a === void 0 ? void 0 : _a.getAllDisplayedColumns();
        if (gridWidth <= 0 || !allDisplayedColumns.length) {
            return;
        }
        var colsToSpread = [];
        var colsToNotSpread = [];
        allDisplayedColumns.forEach(function (column) {
            if (column.getColDef().suppressSizeToFit === true) {
                colsToNotSpread.push(column);
            }
            else {
                colsToSpread.push(column);
            }
        });
        var finishedResizing = false;
        function moveToNotSpread(column) {
            colsToSpread = colsToSpread.filter(function (col) { return col != column; });
            colsToNotSpread.push(column);
        }
        while (!finishedResizing) {
            finishedResizing = true;
            var availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);
            if (availablePixels <= 0) {
                // no width, set everything to minimum
                colsToSpread.forEach(function (column) {
                    column.setMinimum(source);
                });
            }
            else {
                var scale = availablePixels / this.getWidthOfColsInList(colsToSpread);
                // we set the pixels for the last col based on what's left, as otherwise
                // we could be a pixel or two short or extra because of rounding errors.
                var pixelsForLastCol = availablePixels;
                // backwards through loop, as we are removing items as we go
                for (var i = colsToSpread.length - 1; i >= 0; i--) {
                    var column = colsToSpread[i];
                    var newWidth = Math.round(column.getActualWidth() * scale);
                    if (newWidth < column.getMinWidth()) {
                        column.setMinimum(source);
                        moveToNotSpread(column);
                        finishedResizing = false;
                    }
                    else if (column.isGreaterThanMax(newWidth)) {
                        column.setActualWidth(column.getMaxWidth(), source);
                        moveToNotSpread(column);
                        finishedResizing = false;
                    }
                    else {
                        var onLastCol = i === 0;
                        if (onLastCol) {
                            column.setActualWidth(pixelsForLastCol, source);
                        }
                        else {
                            column.setActualWidth(newWidth, source);
                        }
                    }
                    pixelsForLastCol -= newWidth;
                }
            }
        }
        // DANGER: using ag-grid internals
        this.columnApi.columnController.setLeftValues(source);
        this.columnApi.columnController.updateBodyWidths();
    };
    TableFacade.prototype.getWidthOfColsInList = function (columnList) {
        return columnList.reduce(function (width, col) { return width + col.getActualWidth(); }, 0);
    };
    /**
     * Tests whether the provided prepared execution matches the execution that is used to obtain data for this
     * table facade.
     *
     * This is slightly trickier as it needs to accommodate for situations where the underlying execution
     * is being transformed to include new server side sorts / totals. If that operation is in progress, then
     * the transformedExecution will be defined. The code should only compare against this 'soon to be next'
     * execution. This is essential to 'sink' any unneeded full reinits that may happen in some contexts (such as AD)
     * which also listen to sort/total changes and prepare execution for the table from outside. Since
     * the transformation is already in progress, there is no point to reacting to these external stimuli.
     *
     * If the transformation is not happening, then the table is showing data for an existing execution result - in that
     * case the matching goes against the definition backing that result.
     */
    TableFacade.prototype.isMatchingExecution = function (other) {
        if (this.originalExecution.fingerprint() === other.fingerprint()) {
            return true;
        }
        else {
            // eslint-disable-next-line no-console
            console.debug("Original execution fingerprint does not match.");
        }
        if (this.transformedExecution) {
            var matchingTransformed = this.transformedExecution.fingerprint() === other.fingerprint();
            if (!matchingTransformed) {
                // eslint-disable-next-line no-console
                console.debug("transformed execution does not match", this.transformedExecution.definition, other.definition);
            }
            return matchingTransformed;
        }
        var matchingCurrentlyRendered = this.currentFingerprint === other.fingerprint();
        if (!matchingCurrentlyRendered) {
            // eslint-disable-next-line no-console
            console.debug("current result does not match", this.currentResult.definition, other.definition);
        }
        return matchingCurrentlyRendered;
    };
    return TableFacade;
}());
export { TableFacade };
//# sourceMappingURL=tableFacade.js.map