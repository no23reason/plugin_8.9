// (C) 2019-2022 GoodData Corporation
import { __assign, __extends } from "tslib";
import { addIntersectionFiltersToInsight, modifyBucketsAttributesForDrillDown, sanitizeTableProperties, } from "../drillDownUtil";
import cloneDeep from "lodash/cloneDeep";
import flatMap from "lodash/flatMap";
import isNil from "lodash/isNil";
import isEmpty from "lodash/isEmpty";
import isEqual from "lodash/isEqual";
import { bucketAttribute, insightBucket, insightBuckets, insightHasDataDefined, insightProperties, insightSanitize, insightSorts, newAttributeSort, } from "@gooddata/sdk-model";
import { BucketNames, VisualizationTypes } from "@gooddata/sdk-ui";
import { CorePivotTable, pivotTableMenuForCapabilities, } from "@gooddata/sdk-ui-pivot";
import React from "react";
import { render } from "react-dom";
import ReactMeasure from "react-measure";
import { ATTRIBUTE, DATE, METRIC } from "../../../constants/bucket";
import { DASHBOARDS_ENVIRONMENT, ANALYTICAL_ENVIRONMENT } from "../../../constants/properties";
import { configureOverTimeComparison, configurePercent } from "../../../utils/bucketConfig";
import { getAllItemsByType, getItemsFromBuckets, getTotalsFromBucket, removeDuplicateBucketItems, sanitizeFilters, } from "../../../utils/bucketHelper";
import { generateDimensions } from "../../../utils/dimensions";
import { unmountComponentsAtNodes } from "../../../utils/domHelper";
import { getColumnWidthsFromProperties, getReferencePointWithSupportedProperties, } from "../../../utils/propertiesHelper";
import { getPivotTableDefaultUiConfig, setPivotTableUiConfig, } from "../../../utils/uiConfigHelpers/pivotTableUiConfigHelper";
import UnsupportedConfigurationPanel from "../../configurationPanels/UnsupportedConfigurationPanel";
import { AbstractPluggableVisualization } from "../AbstractPluggableVisualization";
import { PIVOT_TABLE_SUPPORTED_PROPERTIES } from "../../../constants/supportedProperties";
import { adaptMdObjectWidthItemsToPivotTable, adaptReferencePointWidthItemsToPivotTable, } from "./widthItemsHelpers";
import { adaptReferencePointSortItemsToPivotTable, addDefaultSort, sanitizePivotTableSorts, } from "./sortItemsHelpers";
import { removeInvalidTotals } from "./totalsHelpers";
export var getColumnAttributes = function (buckets) {
    return getItemsFromBuckets(buckets, [BucketNames.COLUMNS, BucketNames.STACK, BucketNames.SEGMENT], [ATTRIBUTE, DATE]);
};
export var getRowAttributes = function (buckets) {
    return getItemsFromBuckets(buckets, [
        BucketNames.ATTRIBUTE,
        BucketNames.ATTRIBUTES,
        BucketNames.VIEW,
        BucketNames.TREND,
        BucketNames.LOCATION,
    ], [ATTRIBUTE, DATE]);
};
var PluggablePivotTable = /** @class */ (function (_super) {
    __extends(PluggablePivotTable, _super);
    function PluggablePivotTable(props) {
        var _a;
        var _this = _super.call(this, props) || this;
        _this.createCorePivotTableProps = function () {
            var onColumnResized = isManualResizingEnabled(_this.settings) ? _this.onColumnResized : undefined;
            return {
                intl: _this.intl,
                ErrorComponent: null,
                LoadingComponent: null,
                onDrill: _this.onDrill,
                afterRender: _this.afterRender,
                onLoadingChanged: _this.onLoadingChanged,
                pushData: _this.handlePushData,
                onError: _this.onError,
                onExportReady: _this.onExportReady,
                onColumnResized: onColumnResized,
            };
        };
        _this.environment = props.environment;
        _this.renderFun = props.renderFun;
        _this.settings = (_a = props.featureFlags) !== null && _a !== void 0 ? _a : {};
        _this.onColumnResized = _this.onColumnResized.bind(_this);
        _this.handlePushData = _this.handlePushData.bind(_this);
        _this.supportedPropertiesList = PIVOT_TABLE_SUPPORTED_PROPERTIES;
        _this.backendCapabilities = props.backend.capabilities;
        return _this;
    }
    PluggablePivotTable.prototype.unmount = function () {
        unmountComponentsAtNodes([this.element, this.configPanelElement]);
    };
    PluggablePivotTable.prototype.getExtendedReferencePoint = function (referencePoint, previousReferencePoint) {
        var _a, _b, _c, _d, _e;
        var clonedReferencePoint = cloneDeep(referencePoint);
        var newReferencePoint = __assign(__assign({}, clonedReferencePoint), { uiConfig: getPivotTableDefaultUiConfig(multipleDatesEnabled(this.settings)) });
        var buckets = newReferencePoint.buckets;
        var measures = getAllItemsByType(buckets, [METRIC]);
        var rowAttributes = getRowAttributes(buckets);
        var previousRowAttributes = previousReferencePoint && getRowAttributes(previousReferencePoint.buckets);
        var columnAttributes = getColumnAttributes(buckets);
        var previousColumnAttributes = previousReferencePoint && getColumnAttributes(previousReferencePoint.buckets);
        var filters = newReferencePoint.filters
            ? flatMap(newReferencePoint.filters.items, function (item) { return item.filters; })
            : [];
        var totals = removeInvalidTotals(getTotalsFromBucket(buckets, BucketNames.ATTRIBUTE), filters);
        newReferencePoint.buckets = removeDuplicateBucketItems([
            {
                localIdentifier: BucketNames.MEASURES,
                items: measures,
            },
            __assign({ localIdentifier: BucketNames.ATTRIBUTE, items: rowAttributes }, (totals.length > 0 ? { totals: totals } : null)),
            {
                localIdentifier: BucketNames.COLUMNS,
                items: columnAttributes,
            },
        ]);
        var originalSortItems = (_b = (_a = newReferencePoint.properties) === null || _a === void 0 ? void 0 : _a.sortItems) !== null && _b !== void 0 ? _b : [];
        var originalColumnWidths = (_d = (_c = newReferencePoint.properties) === null || _c === void 0 ? void 0 : _c.controls) === null || _d === void 0 ? void 0 : _d.columnWidths;
        var columnWidths = adaptReferencePointWidthItemsToPivotTable(originalColumnWidths, measures, rowAttributes, columnAttributes, previousRowAttributes ? previousRowAttributes : [], previousColumnAttributes ? previousColumnAttributes : [], filters);
        var controlsObj = columnWidths
            ? {
                controls: {
                    columnWidths: columnWidths,
                },
            }
            : {};
        newReferencePoint.properties = __assign({ sortItems: addDefaultSort(adaptReferencePointSortItemsToPivotTable(originalSortItems, measures, rowAttributes, columnAttributes), filters, rowAttributes, previousRowAttributes, columnAttributes, tableSortingCheckDisabled(this.settings)) }, controlsObj);
        setPivotTableUiConfig(newReferencePoint, this.intl, VisualizationTypes.TABLE);
        configurePercent(newReferencePoint, false);
        configureOverTimeComparison(newReferencePoint, !!((_e = this.settings) === null || _e === void 0 ? void 0 : _e["enableWeekFilters"]));
        Object.assign(newReferencePoint, getReferencePointWithSupportedProperties(newReferencePoint, this.supportedPropertiesList));
        return Promise.resolve(sanitizeFilters(newReferencePoint));
    };
    PluggablePivotTable.prototype.getInsightWithDrillDownApplied = function (sourceVisualization, drillDownContext) {
        var drillDownInsight = modifyBucketsAttributesForDrillDown(sourceVisualization, drillDownContext.drillDefinition);
        var drillDownInsightWithFilters = addIntersectionFiltersToInsight(drillDownInsight, drillDownContext.event.drillContext.intersection);
        return sanitizeTableProperties(insightSanitize(drillDownInsightWithFilters));
    };
    PluggablePivotTable.prototype.getExecution = function (options, insight, executionFactory) {
        var _a, _b;
        var dateFormat = options.dateFormat, executionConfig = options.executionConfig;
        return (_a = (_b = executionFactory
            .forInsight(insight))
            .withDimensions.apply(_b, this.getDimensions(insight)))
            .withSorting.apply(_a, getPivotTableSortItems(insight)).withDateFormat(dateFormat)
            .withExecConfig(executionConfig);
    };
    PluggablePivotTable.prototype.updateInstanceProperties = function (options, insight, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    insightPropertiesMeta) {
        _super.prototype.updateInstanceProperties.call(this, options, insight, insightPropertiesMeta);
        /*
         * This was ported from v7. For some reason (likely related KD interop?) the entire content of properties
         * would be picked up and used.
         */
        this.visualizationProperties = insightProperties(insight);
        this.adaptPropertiesToInsight(this.visualizationProperties, this.currentInsight);
    };
    PluggablePivotTable.prototype.renderVisualization = function (options, insight, executionFactory) {
        if (!insightHasDataDefined(insight)) {
            // there is nothing in the insight's bucket that can be visualized
            // bail out
            return;
        }
        var locale = options.locale, custom = options.custom, dimensions = options.dimensions, _a = options.config, config = _a === void 0 ? {} : _a, _b = options.customVisualizationConfig, customVisualizationConfig = _b === void 0 ? {} : _b, theme = options.theme;
        var maxHeight = config.maxHeight, maxWidth = config.maxWidth;
        var height = dimensions === null || dimensions === void 0 ? void 0 : dimensions.height;
        var drillableItems = custom.drillableItems;
        var execution = this.getExecution(options, insight, executionFactory);
        var columnWidths = getColumnWidthsFromProperties(insightProperties(insight));
        var tableConfig = __assign(__assign(__assign({}, createPivotTableConfig(config, this.environment, this.settings, this.backendCapabilities, columnWidths)), customVisualizationConfig), { maxHeight: maxHeight,
            maxWidth: maxWidth });
        var pivotTableProps = __assign(__assign({}, this.createCorePivotTableProps()), { execution: execution,
            drillableItems: drillableItems, config: tableConfig, locale: locale,
            theme: theme });
        if (this.environment === DASHBOARDS_ENVIRONMENT) {
            this.renderFun(React.createElement(ReactMeasure, { client: true }, function (_a) {
                var measureRef = _a.measureRef, contentRect = _a.contentRect;
                var clientHeight = contentRect.client.height;
                var pivotWrapperStyle = {
                    height: isNil(height) ? "100%" : height,
                    textAlign: "left",
                    display: "flex",
                    flex: "1 1 auto",
                    flexDirection: "column",
                };
                var configWithMaxHeight = __assign(__assign(__assign({}, tableConfig), { maxHeight: clientHeight }), customVisualizationConfig);
                return (React.createElement("div", { ref: measureRef, style: pivotWrapperStyle, className: "gd-table-dashboard-wrapper" },
                    React.createElement(CorePivotTable, __assign({}, pivotTableProps, { config: configWithMaxHeight }))));
            }), document.querySelector(this.element));
        }
        else {
            this.renderFun(React.createElement(CorePivotTable, __assign({}, pivotTableProps)), document.querySelector(this.element));
        }
    };
    PluggablePivotTable.prototype.renderConfigurationPanel = function (insight) {
        var _a;
        if (document.querySelector(this.configPanelElement)) {
            var properties = (_a = this.visualizationProperties) !== null && _a !== void 0 ? _a : {};
            // we need to handle cases when attribute previously bearing the default sort is no longer available
            var sanitizedProperties = properties.sortItems
                ? __assign(__assign({}, properties), { sortItems: sanitizePivotTableSorts(properties.sortItems, insightBuckets(insight)) }) : properties;
            render(React.createElement(UnsupportedConfigurationPanel, { locale: this.locale, pushData: this.pushData, properties: sanitizedProperties }), document.querySelector(this.configPanelElement));
        }
    };
    PluggablePivotTable.prototype.getDimensions = function (insight) {
        return generateDimensions(insight, VisualizationTypes.TABLE);
    };
    PluggablePivotTable.prototype.adaptPropertiesToInsight = function (visualizationProperties, insight) {
        // This is sanitization of properties from KD vs current mdObject from AD
        var columnWidths = getColumnWidthsFromProperties(visualizationProperties);
        if (columnWidths) {
            this.sanitizeColumnWidths(columnWidths, insight);
        }
    };
    PluggablePivotTable.prototype.sanitizeColumnWidths = function (columnWidths, insight) {
        if (isEmpty(insightBuckets(insight))) {
            return;
        }
        var adaptedColumnWidths = adaptMdObjectWidthItemsToPivotTable(columnWidths, insight);
        if (!isEqual(columnWidths, adaptedColumnWidths)) {
            this.visualizationProperties.controls.columnWidths = adaptedColumnWidths;
            this.pushData({
                properties: {
                    controls: {
                        columnWidths: adaptedColumnWidths,
                    },
                },
            });
        }
    };
    PluggablePivotTable.prototype.onColumnResized = function (columnWidths) {
        this.pushData({
            properties: {
                controls: {
                    columnWidths: columnWidths,
                },
            },
        });
    };
    PluggablePivotTable.prototype.handlePushData = function (data) {
        if (data && data.properties && data.properties.sortItems) {
            this.pushData({
                properties: {
                    sortItems: data.properties.sortItems,
                },
            });
        }
        else {
            this.pushData(data);
        }
    };
    return PluggablePivotTable;
}(AbstractPluggableVisualization));
export { PluggablePivotTable };
function isManualResizingEnabled(settings) {
    return settings["enableTableColumnsManualResizing"] === true;
}
function multipleDatesEnabled(settings) {
    return settings["enableMultipleDates"] === true;
}
function tableSortingCheckDisabled(settings) {
    return settings["tableSortingCheckDisabled"] === true;
}
/**
 * Given plug viz GDC config, current environment and platform settings, this creates pivot table config.
 *
 * @internal
 */
export function createPivotTableConfig(config, environment, settings, capabilities, columnWidths) {
    var tableConfig = {
        separators: config.separators,
    };
    if (environment !== DASHBOARDS_ENVIRONMENT) {
        tableConfig = __assign(__assign({}, tableConfig), { menu: pivotTableMenuForCapabilities(capabilities, {
                aggregations: true,
                aggregationsSubMenu: true,
            }) });
    }
    var autoSize = settings["enableTableColumnsAutoResizing"];
    // the growToFit can only be enabled in dashboards
    var growToFit = environment === DASHBOARDS_ENVIRONMENT && settings["enableTableColumnsGrowToFit"];
    var manualResizing = settings["enableTableColumnsManualResizing"];
    var columnSizing = {};
    if (autoSize) {
        columnSizing = {
            defaultWidth: config.isExportMode ? "viewport" : "autoresizeAll",
        };
    }
    if (growToFit) {
        columnSizing = __assign(__assign({}, columnSizing), { growToFit: true });
    }
    if (manualResizing && columnWidths && columnWidths.length > 0) {
        columnSizing = __assign(__assign({}, columnSizing), { columnWidths: columnWidths });
    }
    if (environment === ANALYTICAL_ENVIRONMENT) {
        columnSizing = __assign(__assign({}, columnSizing), { growToFit: false });
    }
    return __assign(__assign({}, tableConfig), { columnSizing: columnSizing });
}
/**
 * This function exists to overcome AD weirdness where AD will sometimes send insight without any
 * sorts even if the pivot table should be sorted by default by the first row attribute in ascending order. Code here
 * fixes this symptom and ensures the default sort is in place.
 *
 * Note: while this may seem small thing, it's actually a messy business. When rendering / switching to the pivot
 * table the AD will call update/render multiple times. Sometimes with sort items, sometimes without sort items. This
 * can seriously mess up the pivot table in return: the column resizing is susceptible to race conditions and timing
 * issues. Because of the flurry of calls, the table may not render or may render not resized at all.
 */
function getPivotTableSortItems(insight) {
    var sorts = insightSorts(insight);
    if (!isEmpty(sorts)) {
        /*
         * This is here to ensure that when rendering pivot table in KD, all invalid sort items
         * are filtered out. At this moment, core pivot table does not handle invalid sorts so well and
         * they can knock it off balance and it won't show up (interplay with resizing).
         *
         * Fixing core pivot to strip out invalid sorts has to happen one day - however regardless of that,
         * it is still the responsibility of the PluggablePivotTable to call the CorePivot correctly and so this
         * sanitization here also makes sense.
         */
        return sanitizePivotTableSorts(sorts, insightBuckets(insight));
    }
    var rowBucket = insightBucket(insight, BucketNames.ATTRIBUTE);
    var rowAttribute = rowBucket && bucketAttribute(rowBucket);
    if (rowAttribute) {
        return [newAttributeSort(rowAttribute, "asc")];
    }
}
//# sourceMappingURL=PluggablePivotTable.js.map