import { __assign, __extends } from "tslib";
import { bucketsIsEmpty, insightBuckets, insightHasMeasures, insightMeasures, } from "@gooddata/sdk-model";
import { BucketNames, VisualizationTypes } from "@gooddata/sdk-ui";
import { BaseChart, ColorUtils, updateConfigWithSettings, } from "@gooddata/sdk-ui-charts";
import React from "react";
import { render } from "react-dom";
import { BUCKETS } from "../../../constants/bucket";
import { DASHBOARDS_ENVIRONMENT } from "../../../constants/properties";
import { BASE_CHART_SUPPORTED_PROPERTIES } from "../../../constants/supportedProperties";
import { DEFAULT_BASE_CHART_UICONFIG, MAX_CATEGORIES_COUNT } from "../../../constants/uiConfig";
import { InvalidBucketsSdkError, } from "../../../interfaces/Visualization";
import { configureOverTimeComparison, configurePercent } from "../../../utils/bucketConfig";
import { filterOutDerivedMeasures, getAllAttributeItemsWithPreference, getAttributeItemsWithoutStacks, getFilteredMeasuresForStackedCharts, getMeasureItems, getStackItems, isNotDateBucketItem, sanitizeFilters, } from "../../../utils/bucketHelper";
import { getValidProperties } from "../../../utils/colors";
import { generateDimensions } from "../../../utils/dimensions";
import { unmountComponentsAtNodes } from "../../../utils/domHelper";
import { getHighchartsAxisNameConfiguration, getReferencePointWithSupportedProperties, getSupportedPropertiesControls, getDataPointsConfiguration, hasColorMapping, isEmptyObject, } from "../../../utils/propertiesHelper";
import { createSorts, removeSort } from "../../../utils/sort";
import { getTranslation } from "../../../utils/translations";
import { setBaseChartUiConfig, setBaseChartUiConfigRecommendations, } from "../../../utils/uiConfigHelpers/baseChartUiConfigHelper";
import { isOpenAsReportSupportedByVisualization } from "../../../utils/visualizationsHelper";
import BaseChartConfigurationPanel from "../../configurationPanels/BaseChartConfigurationPanel";
import { AbstractPluggableVisualization } from "../AbstractPluggableVisualization";
import cloneDeep from "lodash/cloneDeep";
import isEmpty from "lodash/isEmpty";
import set from "lodash/set";
import tail from "lodash/tail";
import { addIntersectionFiltersToInsight, modifyBucketsAttributesForDrillDown } from "../drillDownUtil";
var PluggableBaseChart = /** @class */ (function (_super) {
    __extends(PluggableBaseChart, _super);
    function PluggableBaseChart(props) {
        var _this = _super.call(this, props) || this;
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        _this.handlePushData = function (data) {
            var resultingData = data;
            if (data.colors) {
                _this.handleConfirmedColorMapping(data);
            }
            else {
                _this.pushData(__assign(__assign({}, resultingData), { references: _this.references }));
            }
        };
        _this.projectId = props.projectId;
        _this.environment = props.environment;
        _this.type = VisualizationTypes.COLUMN;
        _this.featureFlags = props.featureFlags ? props.featureFlags : {};
        _this.ignoreUndoRedo = false;
        _this.defaultControlsProperties = {};
        _this.setCustomControlsProperties({});
        _this.renderFun = props.renderFun;
        _this.supportedPropertiesList = _this.getSupportedPropertiesList();
        return _this;
    }
    PluggableBaseChart.prototype.unmount = function () {
        unmountComponentsAtNodes([this.element, this.configPanelElement]);
    };
    PluggableBaseChart.prototype.getUiConfig = function () {
        return cloneDeep(DEFAULT_BASE_CHART_UICONFIG);
    };
    PluggableBaseChart.prototype.getExtendedReferencePoint = function (referencePoint) {
        var clonedReferencePoint = cloneDeep(referencePoint);
        var uiConfig = this.getUiConfig();
        var newReferencePoint = __assign(__assign({}, clonedReferencePoint), { uiConfig: uiConfig });
        this.configureBuckets(newReferencePoint);
        newReferencePoint = configurePercent(newReferencePoint, false);
        newReferencePoint = configureOverTimeComparison(newReferencePoint, !!this.featureFlags["enableWeekFilters"]);
        newReferencePoint = setBaseChartUiConfigRecommendations(newReferencePoint, this.type, !!this.featureFlags["enableWeekFilters"]);
        newReferencePoint = getReferencePointWithSupportedProperties(newReferencePoint, this.supportedPropertiesList);
        newReferencePoint = setBaseChartUiConfig(newReferencePoint, this.intl, this.type);
        newReferencePoint = removeSort(newReferencePoint);
        return Promise.resolve(sanitizeFilters(newReferencePoint));
    };
    PluggableBaseChart.prototype.getInsightWithDrillDownApplied = function (source, drillDownContext) {
        var intersection = drillDownContext.event.drillContext.intersection;
        var withFilters = addIntersectionFiltersToInsight(source, intersection);
        return modifyBucketsAttributesForDrillDown(withFilters, drillDownContext.drillDefinition);
    };
    PluggableBaseChart.prototype.isOpenAsReportSupported = function () {
        return isOpenAsReportSupportedByVisualization(this.type);
    };
    PluggableBaseChart.prototype.setCustomControlsProperties = function (customControlsProperties) {
        this.customControlsProperties = customControlsProperties;
    };
    PluggableBaseChart.prototype.getExecution = function (options, insight, executionFactory) {
        var _a, _b;
        var dateFormat = options.dateFormat, executionConfig = options.executionConfig;
        var supportedControls = this.getSupportedControls(insight, options);
        return (_a = (_b = executionFactory
            .forInsight(insight))
            .withDimensions.apply(_b, this.getDimensions(insight)))
            .withSorting.apply(_a, createSorts(this.type, insight, canSortStackTotalValue(insight, supportedControls))).withDateFormat(dateFormat)
            .withExecConfig(executionConfig);
    };
    PluggableBaseChart.prototype.configureBuckets = function (extendedReferencePoint) {
        var _a, _b, _c, _d, _e;
        var buckets = (_a = extendedReferencePoint === null || extendedReferencePoint === void 0 ? void 0 : extendedReferencePoint.buckets) !== null && _a !== void 0 ? _a : [];
        var categoriesCount = (_e = (_d = (_c = (_b = extendedReferencePoint === null || extendedReferencePoint === void 0 ? void 0 : extendedReferencePoint.uiConfig) === null || _b === void 0 ? void 0 : _b.buckets) === null || _c === void 0 ? void 0 : _c[BucketNames.VIEW]) === null || _d === void 0 ? void 0 : _d.itemsLimit) !== null && _e !== void 0 ? _e : MAX_CATEGORIES_COUNT;
        set(extendedReferencePoint, BUCKETS, [
            {
                localIdentifier: BucketNames.MEASURES,
                items: getFilteredMeasuresForStackedCharts(buckets),
            },
            {
                localIdentifier: BucketNames.VIEW,
                items: getAttributeItemsWithoutStacks(buckets).slice(0, categoriesCount),
            },
            {
                localIdentifier: BucketNames.STACK,
                items: this.getStackItems(buckets),
            },
        ]);
    };
    PluggableBaseChart.prototype.getSupportedPropertiesList = function () {
        return BASE_CHART_SUPPORTED_PROPERTIES;
    };
    PluggableBaseChart.prototype.getStackItems = function (buckets) {
        var measures = getMeasureItems(buckets);
        var masterMeasures = filterOutDerivedMeasures(measures);
        var allAttributes = getAllAttributeItemsWithPreference(buckets, [
            BucketNames.LOCATION,
            BucketNames.VIEW,
            BucketNames.TREND,
            BucketNames.STACK,
            BucketNames.SEGMENT,
        ]);
        var stacks = getStackItems(buckets);
        if (masterMeasures.length <= 1 && allAttributes.length > 1) {
            // first attribute is taken, find next available non-date attribute
            var attributesWithoutFirst = tail(allAttributes);
            var nonDate = attributesWithoutFirst.filter(isNotDateBucketItem);
            stacks = nonDate.slice(0, 1);
        }
        return stacks;
    };
    PluggableBaseChart.prototype.checkBeforeRender = function (insight) {
        _super.prototype.checkBeforeRender.call(this, insight);
        if (!insightHasMeasures(insight)) {
            throw new InvalidBucketsSdkError();
        }
        return true;
    };
    PluggableBaseChart.prototype.renderVisualization = function (options, insight, executionFactory) {
        var _a = options.dimensions, dimensions = _a === void 0 ? { height: undefined } : _a, _b = options.custom, custom = _b === void 0 ? {} : _b, locale = options.locale, theme = options.theme;
        var height = dimensions.height;
        // keep height undef for AD; causes indigo-visualizations to pick default 100%
        var resultingHeight = this.environment === DASHBOARDS_ENVIRONMENT ? height : undefined;
        var drillableItems = custom.drillableItems;
        var supportedControls = this.getSupportedControls(insight, options);
        var configSupportedControls = isEmpty(supportedControls) ? null : supportedControls;
        var fullConfig = this.buildVisualizationConfig(options, configSupportedControls);
        var execution = this.getExecution(options, insight, executionFactory);
        this.renderFun(React.createElement(BaseChart, { execution: execution, afterRender: this.afterRender, drillableItems: drillableItems, onDrill: this.onDrill, onError: this.onError, onExportReady: this.onExportReady, onLoadingChanged: this.onLoadingChanged, pushData: this.handlePushData, height: resultingHeight, type: this.type, locale: locale, config: updateConfigWithSettings(fullConfig, this.featureFlags), LoadingComponent: null, ErrorComponent: null, theme: theme }), document.querySelector(this.element));
    };
    PluggableBaseChart.prototype.initializeProperties = function (visualizationProperties) {
        var controls = visualizationProperties === null || visualizationProperties === void 0 ? void 0 : visualizationProperties.controls;
        var supportedProperties = getSupportedPropertiesControls(controls, this.supportedPropertiesList);
        var initialProperties = {
            supportedProperties: { controls: supportedProperties },
        };
        this.pushData({
            initialProperties: initialProperties,
        });
    };
    PluggableBaseChart.prototype.renderConfigurationPanel = function (insight) {
        if (document.querySelector(this.configPanelElement)) {
            render(React.createElement(BaseChartConfigurationPanel, { locale: this.locale, references: this.references, properties: this.visualizationProperties, propertiesMeta: this.propertiesMeta, insight: insight, colors: this.colors, pushData: this.handlePushData, type: this.type, isError: this.getIsError(), isLoading: this.isLoading, featureFlags: this.featureFlags, axis: this.axis }), document.querySelector(this.configPanelElement));
        }
    };
    PluggableBaseChart.prototype.getDimensions = function (insight) {
        return generateDimensions(insight, this.type);
    };
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    PluggableBaseChart.prototype.handleConfirmedColorMapping = function (data) {
        var resultingData = data;
        this.colors = data.colors;
        if (isEmptyObject(this.references)) {
            resultingData.references = {};
        }
        else if (this.references) {
            resultingData.references = this.references;
        }
        if (this.visualizationProperties) {
            resultingData.properties = getValidProperties(this.visualizationProperties, data.colors.colorAssignments);
            this.visualizationProperties = resultingData.properties;
        }
        this.renderConfigurationPanel(this.currentInsight);
        var openAsReportConfig = this.getOpenAsReportConfig(resultingData.properties);
        if (this.ignoreUndoRedo) {
            this.ignoreUndoRedo = false;
            this.pushData(resultingData);
        }
        else {
            this.pushData(__assign({ openAsReport: openAsReportConfig, ignoreUndoRedo: true }, resultingData));
        }
    };
    PluggableBaseChart.prototype.buildVisualizationConfig = function (options, supportedControls) {
        var _a = options.config, config = _a === void 0 ? {} : _a, _b = options.customVisualizationConfig, customVisualizationConfig = _b === void 0 ? {} : _b;
        var colorMapping = supportedControls === null || supportedControls === void 0 ? void 0 : supportedControls.colorMapping;
        var validColorMapping = colorMapping &&
            colorMapping
                .filter(function (mapping) { return mapping != null; })
                .map(function (mapItem) { return ({
                predicate: ColorUtils.getColorMappingPredicate(mapItem.id),
                color: mapItem.color,
            }); });
        return __assign(__assign(__assign({ separators: config.separators, colorPalette: config.colorPalette, forceDisableDrillOnAxes: config.forceDisableDrillOnAxes }, supportedControls), { colorMapping: validColorMapping && validColorMapping.length > 0 ? validColorMapping : null }), customVisualizationConfig);
    };
    PluggableBaseChart.prototype.getOpenAsReportConfig = function (properties) {
        var hasMapping = hasColorMapping(properties);
        var isSupported = this.isOpenAsReportSupported();
        var warningMessage = hasMapping ? getTranslation("export_unsupported.colors", this.intl) : "";
        return {
            supported: isSupported && !hasMapping,
            warningMessage: warningMessage,
        };
    };
    PluggableBaseChart.prototype.getSupportedControls = function (insight, options) {
        var _a, _b;
        var supportedControls = cloneDeep((_b = (_a = this.visualizationProperties) === null || _a === void 0 ? void 0 : _a.controls) !== null && _b !== void 0 ? _b : {});
        var defaultControls = getSupportedPropertiesControls(this.defaultControlsProperties, this.supportedPropertiesList);
        var customControls = getSupportedPropertiesControls(this.customControlsProperties, this.supportedPropertiesList);
        var legendPosition = this.getLegendPosition(supportedControls, insight, options);
        // Set legend position by bucket items and environment
        set(supportedControls, "legend.position", legendPosition);
        if (this.environment === DASHBOARDS_ENVIRONMENT) {
            var legendResponsiveness = this.featureFlags["enableKDWidgetCustomHeight"]
                ? "autoPositionWithPopup"
                : true;
            set(supportedControls, "legend.responsive", legendResponsiveness);
        }
        supportedControls = getHighchartsAxisNameConfiguration(supportedControls, this.featureFlags["enableAxisNameConfiguration"]);
        supportedControls = getDataPointsConfiguration(supportedControls, this.featureFlags["enableHidingOfDataPoints"]);
        return __assign(__assign(__assign({}, defaultControls), supportedControls), customControls);
    };
    PluggableBaseChart.prototype.getLegendPosition = function (controlProperties, insight, options) {
        var _a, _b, _c;
        var legendPosition = (_b = (_a = controlProperties === null || controlProperties === void 0 ? void 0 : controlProperties.legend) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : "auto";
        if (this.environment === DASHBOARDS_ENVIRONMENT) {
            var width = (_c = options.dimensions) === null || _c === void 0 ? void 0 : _c.width;
            return width !== undefined && width <= getMaxWidthForCollapsedLegend(legendPosition)
                ? "top"
                : legendPosition;
        }
        return legendPosition === "auto" && isStacked(insight) ? "right" : legendPosition;
    };
    PluggableBaseChart.prototype.isMultipleDatesEnabled = function () {
        //this is development FF and will be removed in the end of dev cycle
        return !!this.featureFlags["enableMultipleDates"];
    };
    return PluggableBaseChart;
}(AbstractPluggableVisualization));
export { PluggableBaseChart };
function isStacked(insight) {
    return !bucketsIsEmpty(insightBuckets(insight, BucketNames.STACK, BucketNames.SEGMENT));
}
function areAllMeasuresOnSingleAxis(insight, secondaryYAxis) {
    var _a, _b;
    var measureCount = insightMeasures(insight).length;
    var numberOfMeasureOnSecondaryAxis = (_b = (_a = secondaryYAxis.measures) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    return numberOfMeasureOnSecondaryAxis === 0 || measureCount === numberOfMeasureOnSecondaryAxis;
}
function canSortStackTotalValue(insight, supportedControls) {
    var _a, _b;
    var stackMeasures = (_a = supportedControls === null || supportedControls === void 0 ? void 0 : supportedControls.stackMeasures) !== null && _a !== void 0 ? _a : false;
    var secondaryAxis = (_b = supportedControls === null || supportedControls === void 0 ? void 0 : supportedControls.secondary_yaxis) !== null && _b !== void 0 ? _b : { measures: [] };
    var allMeasuresOnSingleAxis = areAllMeasuresOnSingleAxis(insight, secondaryAxis);
    return stackMeasures && allMeasuresOnSingleAxis;
}
var MAX_WIDTH_FOR_COLLAPSED_LEGEND = 440;
var MAX_WIDTH_FOR_COLLAPSED_AUTO_LEGEND = 610;
function getMaxWidthForCollapsedLegend(legendPosition) {
    return legendPosition === "auto" ? MAX_WIDTH_FOR_COLLAPSED_AUTO_LEGEND : MAX_WIDTH_FOR_COLLAPSED_LEGEND;
}
//# sourceMappingURL=PluggableBaseChart.js.map