// (C) 2022 GoodData Corporation
import { __assign, __read, __spread } from "tslib";
import noop from "lodash/noop";
import { createDashboardStore } from "../store/dashboardStore";
import { queryEnvelopeWithPromise } from "../store/_infra/queryProcessing";
/**
 * @internal
 */
var HeadlessDashboard = /** @class */ (function () {
    function HeadlessDashboard(ctx, config) {
        var _this = this;
        this.monitoredActions = {};
        this.capturedActions = [];
        this.capturedEvents = [];
        this.getOrCreateMonitoredAction = function (actionType) {
            var existingAction = _this.monitoredActions[actionType];
            if (existingAction) {
                return existingAction;
            }
            var partialAction = {
                calls: 0,
                resolve: noop,
                reject: noop,
            };
            var promise = new Promise(function (resolve, reject) {
                partialAction.resolve = resolve;
                partialAction.reject = reject;
            });
            var newAction = __assign(__assign({}, partialAction), { promise: promise });
            _this.monitoredActions[actionType] = newAction;
            return newAction;
        };
        this.onActionCaptured = function (action) {
            _this.capturedActions.push(action);
            var monitoredAction = _this.getOrCreateMonitoredAction(action.type);
            monitoredAction.calls += 1;
            monitoredAction.resolve(action);
        };
        this.eventHandler = function (evt) {
            _this.capturedEvents.push(evt);
        };
        this.commandFailedRejectsWaitFor = function () {
            var commandFailed = _this.getOrCreateMonitoredAction("GDC.DASH/EVT.COMMAND.FAILED");
            return commandFailed.promise.then(function (evt) {
                // eslint-disable-next-line no-console
                console.error("Command processing failed: " + evt.payload.reason + " - " + evt.payload.message);
                throw evt.payload.error;
            });
        };
        this.commandRejectedEndsWaitFor = function () {
            var commandRejected = _this.getOrCreateMonitoredAction("GDC.DASH/EVT.COMMAND.REJECTED");
            return commandRejected.promise.then(function (evt) {
                // eslint-disable-next-line no-console
                console.error("Command was rejected because dashboard does not know how to handle it. " +
                    "This is likely because the handler for the rejected command is not registered in the system. See root command handler.");
                throw evt;
            });
        };
        // Middleware to store the actions and create promises
        var actionsMiddleware = function () { return function (next) { return function (action) {
            if (action.type.startsWith("@@redux/")) {
                //
            }
            else {
                _this.onActionCaptured(action);
            }
            return next(action);
        }; }; };
        this.reduxedStore = createDashboardStore({
            dashboardContext: ctx,
            additionalMiddleware: actionsMiddleware,
            eventing: {
                initialEventHandlers: [
                    {
                        eval: function () { return true; },
                        handler: this.eventHandler,
                    },
                ],
            },
            queryServices: config === null || config === void 0 ? void 0 : config.queryServices,
            backgroundWorkers: (config === null || config === void 0 ? void 0 : config.backgroundWorkers) || [],
            privateContext: config === null || config === void 0 ? void 0 : config.customizationFns,
        });
    }
    HeadlessDashboard.prototype.dispatch = function (action) {
        /*
         * Clearing monitored actions is essential to allow sane usage in tests that need fire a command and wait
         * for the same type of event multiple times. Monitored actions is what is used to wait in the `waitFor`
         * method. Without the clearing, the second `waitFor` would bail out immediately and return the very first
         * captured event.
         */
        this.monitoredActions = {};
        this.reduxedStore.store.dispatch(action);
    };
    /**
     * Convenience function that combines both {@link HeadlessDashboard.dispatch} and {@link HeadlessDashboard.waitFor}.
     *
     * @param action - action (typically a command) to dispatch
     * @param actionType - type of action (typically an event type) to wait for
     * @param timeout - timeout after which the wait fails, default is 1000
     */
    HeadlessDashboard.prototype.dispatchAndWaitFor = function (action, actionType, timeout) {
        if (timeout === void 0) { timeout = 1000; }
        this.dispatch(action);
        return this.waitFor(actionType, timeout);
    };
    /**
     * Starts a dashboard query.
     *
     * @param action - query action
     */
    HeadlessDashboard.prototype.query = function (action) {
        var _a = queryEnvelopeWithPromise(action), envelope = _a.envelope, promise = _a.promise;
        this.reduxedStore.store.dispatch(envelope);
        return promise;
    };
    /**
     * Wait for action to occur. The wait is bounded by a timeout that is 1s by default.
     *
     * @param actionType - action type to wait for
     * @param timeout - timeout after which the wait fails, default is 1000
     */
    HeadlessDashboard.prototype.waitFor = function (actionType, timeout) {
        if (timeout === void 0) { timeout = 1000; }
        var includeErrorHandler = actionType !== "GDC.DASH/EVT.COMMAND.FAILED";
        return Promise.race(__spread([
            this.getOrCreateMonitoredAction(actionType).promise
        ], (includeErrorHandler ? [this.commandFailedRejectsWaitFor()] : []), [
            this.commandRejectedEndsWaitFor(),
            new Promise(function (_, reject) {
                setTimeout(function () {
                    reject(new Error("Wait for action '" + actionType + "' timed out after " + timeout + "ms"));
                }, timeout);
            }),
        ]));
    };
    /**
     * select data from the state
     */
    HeadlessDashboard.prototype.select = function (selectorFactory) {
        return selectorFactory(this.state());
    };
    /**
     * Returns dashboard state.
     */
    HeadlessDashboard.prototype.state = function () {
        return this.reduxedStore.store.getState();
    };
    return HeadlessDashboard;
}());
export { HeadlessDashboard };
//# sourceMappingURL=HeadlessDashboard.js.map