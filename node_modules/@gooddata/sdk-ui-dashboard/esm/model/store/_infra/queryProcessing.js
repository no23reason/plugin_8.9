// (C) 2021-2022 GoodData Corporation
import { __generator } from "tslib";
import { actionChannel, call, spawn, take } from "redux-saga/effects";
import keyBy from "lodash/keyBy";
import { combineReducers } from "@reduxjs/toolkit";
import fromPairs from "lodash/fromPairs";
import noop from "lodash/noop";
import compact from "lodash/compact";
import { dispatchDashboardEvent } from "./eventDispatcher";
import { internalQueryErrorOccurred, isDashboardQueryFailed, queryCompleted, queryRejected, queryStarted, } from "../../events/general";
import { getDashboardContext } from "./contexts";
/**
 * @internal
 */
export var QueryEnvelopeActionPrefix = "__Q";
function isQueryEnvelope(obj) {
    return !!obj && obj.type.startsWith(QueryEnvelopeActionPrefix);
}
/**
 * @internal
 */
export function queryEnvelope(query, eventHandlers, refresh) {
    var _a, _b, _c;
    if (refresh === void 0) { refresh = false; }
    return {
        type: QueryEnvelopeActionPrefix + "(" + query.type + ")",
        query: query,
        refresh: refresh,
        onError: (_a = eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onError) !== null && _a !== void 0 ? _a : noop,
        onStart: (_b = eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onStart) !== null && _b !== void 0 ? _b : noop,
        onSuccess: (_c = eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onSuccess) !== null && _c !== void 0 ? _c : noop,
    };
}
/**
 * @internal
 */
export function queryEnvelopeWithPromise(query, refresh) {
    if (refresh === void 0) { refresh = false; }
    var queryEnvelopeEventHandlers = {};
    var promise = new Promise(function (resolve, reject) {
        queryEnvelopeEventHandlers.onSuccess = resolve;
        queryEnvelopeEventHandlers.onError = reject;
    });
    var envelope = queryEnvelope(query, queryEnvelopeEventHandlers, refresh);
    return {
        promise: promise,
        envelope: envelope,
    };
}
function processQuery(service, ctx, envelope) {
    var query, _a, type, correlationId, correlationIdForLog, result, e_1;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                query = envelope.query, _a = envelope.query, type = _a.type, correlationId = _a.correlationId;
                correlationIdForLog = correlationId !== null && correlationId !== void 0 ? correlationId : "(no correlationId provided)";
                _c.label = 1;
            case 1:
                _c.trys.push([1, 5, , 10]);
                try {
                    envelope.onStart(query);
                }
                catch (e) {
                    // eslint-disable-next-line no-console
                    console.warn("An error has occurred while calling onStart function provided for " + type + "@" + correlationIdForLog + " processing:", e);
                }
                return [4 /*yield*/, dispatchDashboardEvent(queryStarted(ctx, query, correlationId))];
            case 2:
                _c.sent();
                return [4 /*yield*/, call(service.generator, ctx, envelope.query, (_b = envelope.refresh) !== null && _b !== void 0 ? _b : false)];
            case 3:
                result = _c.sent();
                try {
                    envelope.onSuccess(result);
                }
                catch (e) {
                    // eslint-disable-next-line no-console
                    console.warn("An error has occurred while calling onSuccess function provided for " + type + "@" + correlationIdForLog + " processing", e);
                }
                return [4 /*yield*/, dispatchDashboardEvent(queryCompleted(ctx, query, result, correlationId))];
            case 4:
                _c.sent();
                return [3 /*break*/, 10];
            case 5:
                e_1 = _c.sent();
                try {
                    envelope.onError(e_1);
                }
                catch (ne) {
                    // eslint-disable-next-line no-console
                    console.warn("An error has occurred while calling onError function provided for " + type + "@" + correlationIdForLog + " processing:", ne);
                }
                if (!isDashboardQueryFailed(e_1)) return [3 /*break*/, 7];
                return [4 /*yield*/, dispatchDashboardEvent(e_1)];
            case 6:
                _c.sent();
                return [3 /*break*/, 9];
            case 7: return [4 /*yield*/, dispatchDashboardEvent(internalQueryErrorOccurred(ctx, "An internal error has occurred while processing " + type, e_1, correlationId))];
            case 8:
                _c.sent();
                _c.label = 9;
            case 9: return [3 /*break*/, 10];
            case 10: return [2 /*return*/];
        }
    });
}
function ensureQueryWrappedInEnvelope(action) {
    return isQueryEnvelope(action) ? action : queryEnvelope(action);
}
/**
 * Creates components that should be integrated into the dashboard store in order to facilitate query processing.
 *
 * @param queryServices - query services use to initialize the components
 */
export function createQueryProcessingModule(queryServices) {
    var servicesByType = keyBy(queryServices, function (service) { return service.name; });
    var queryToReducers = fromPairs(compact(queryServices.map(function (service) {
        if (!service.cache) {
            return null;
        }
        return [service.cache.cacheName, service.cache.reducer];
    })));
    return {
        queryCacheReducer: combineReducers(queryToReducers),
        /*
         * The root saga for all query processing. This will channel in all query envelopes and all non-enveloped
         * queries and will dispatch the query
         */
        rootQueryProcessor: function () {
            var queryChannel, query, envelope, dashboardContext, service;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, actionChannel(function (action) {
                            return action.type &&
                                (action.type.startsWith(QueryEnvelopeActionPrefix) ||
                                    action.type.startsWith("GDC.DASH/QUERY."));
                        })];
                    case 1:
                        queryChannel = _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!true) return [3 /*break*/, 9];
                        return [4 /*yield*/, take(queryChannel)];
                    case 3:
                        query = _a.sent();
                        envelope = ensureQueryWrappedInEnvelope(query);
                        return [4 /*yield*/, call(getDashboardContext)];
                    case 4:
                        dashboardContext = _a.sent();
                        service = servicesByType[envelope.query.type];
                        if (!!service) return [3 /*break*/, 6];
                        return [4 /*yield*/, dispatchDashboardEvent(queryRejected(dashboardContext, envelope.query.correlationId))];
                    case 5:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, spawn(processQuery, service, dashboardContext, envelope)];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8: return [3 /*break*/, 2];
                    case 9: return [2 /*return*/];
                }
            });
        },
    };
}
//# sourceMappingURL=queryProcessing.js.map