import { __generator } from "tslib";
import { createEntityAdapter, createSelector, createSlice, } from "@reduxjs/toolkit";
import { call, put, select } from "redux-saga/effects";
import memoize from "lodash/memoize";
import { invariant } from "ts-invariant";
import capitalize from "lodash/capitalize";
/**
 * Given query name, this function will create name to use for the slice that will hold the cache with query results.
 *
 * For slice name, the function drops the "GDC.DASH/QUERY." prefix and then the rest is camel-cased with the word 'Cache' appended at the end.
 *
 * @param queryName - query name in format GDC.DASH/QUERY.SOME.THING
 */
export function createSliceNameForQueryCache(queryName) {
    var withoutPrefix = queryName.split("/")[1];
    invariant(withoutPrefix, "Trying to create slice for query data but the query type name seems invalid: " + queryName + ". Must always start with \"GDC.DASH/QUERY.\" prefix");
    // take the part after GDC.DASH/, split it into segments, drop the first segment (QUERY) and then capitalize the rest
    var segments = withoutPrefix.split(".").slice(1).map(capitalize);
    // and make sure the first segment is back to lowercase
    segments[0] = segments[0].toLowerCase();
    return segments.join("") + "Cache";
}
function createQueryCacheSlice(queryName, selectId) {
    var sliceName = createSliceNameForQueryCache(queryName);
    var cacheEntryId = function (entry) { return selectId(entry.query); };
    var adapter = createEntityAdapter({ selectId: cacheEntryId });
    // TODO: getting massive typing errors here, don't know how to solve them
    var reducers = {
        set: adapter.setOne,
        remove: adapter.removeOne,
        removeAll: adapter.removeAll,
    };
    var slice = createSlice({
        name: sliceName,
        initialState: adapter.getInitialState(),
        reducers: reducers,
    });
    var cacheSelectors = adapter.getSelectors(function (state) { return state._queryCache[sliceName]; });
    var selectById = function (id) {
        return createSelector(function (state) { return state; }, function (state) {
            return cacheSelectors.selectById(state, id);
        });
    };
    var selectQueryResult = memoize(function (query) {
        var id = selectId(query);
        return createSelector(function (state) { return state; }, function (state) {
            return cacheSelectors.selectById(state, id);
        });
    }, function (query) { return selectId(query); });
    return {
        cacheName: sliceName,
        reducer: slice.reducer,
        actions: slice.actions,
        selectQueryResult: selectQueryResult,
        selectById: selectById,
    };
}
/**
 * Creates a query service whose results will be stored in the dashboard component's state. Cached query
 * services are useful when the query itself requires expensive operation backend.
 *
 * The dashboard store takes care of everything related to
 *
 * @param queryName - name of the query
 * @param generator - the generator function that processes the query
 * @param queryToCacheKey - function to map query into a cache key under which to store the results
 */
export function createCachedQueryService(queryName, generator, queryToCacheKey) {
    var queryCache = createQueryCacheSlice(queryName, queryToCacheKey);
    function generatorWithQueryCache(ctx, query, refresh) {
        var cacheKey, cachedResult, result, e_1;
        if (refresh === void 0) { refresh = false; }
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    cacheKey = queryToCacheKey(query);
                    return [4 /*yield*/, select(queryCache.selectById(cacheKey))];
                case 1:
                    cachedResult = _a.sent();
                    if (cachedResult && cachedResult.result && !refresh) {
                        return [2 /*return*/, cachedResult.result];
                    }
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 6, , 8]);
                    return [4 /*yield*/, put(queryCache.actions.set({
                            query: query,
                            status: "loading",
                        }))];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, call(generator, ctx, query)];
                case 4:
                    result = _a.sent();
                    return [4 /*yield*/, put(queryCache.actions.set({
                            query: query,
                            status: "success",
                            result: result,
                        }))];
                case 5:
                    _a.sent();
                    return [2 /*return*/, result];
                case 6:
                    e_1 = _a.sent();
                    return [4 /*yield*/, put(queryCache.actions.set({
                            query: query,
                            status: "error",
                            error: e_1.message,
                        }))];
                case 7:
                    _a.sent();
                    throw e_1;
                case 8: return [2 /*return*/];
            }
        });
    }
    return {
        name: queryName,
        generator: generatorWithQueryCache,
        cache: queryCache,
    };
}
/**
 * Creates a non-cached query service.
 *
 * @param queryName - name of the query
 * @param generator - the generator function that processes the query
 */
export function createQueryService(queryName, generator) {
    return {
        name: queryName,
        generator: generator,
    };
}
//# sourceMappingURL=queryService.js.map