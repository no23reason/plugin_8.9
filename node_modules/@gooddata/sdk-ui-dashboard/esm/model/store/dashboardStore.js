import { __assign, __generator, __read, __spread, __values } from "tslib";
// (C) 2021-2022 GoodData Corporation
import { combineReducers, configureStore, getDefaultMiddleware, } from "@reduxjs/toolkit";
import createSagaMiddleware from "redux-saga";
import { enableBatching } from "redux-batched-actions";
import { v4 as uuidv4 } from "uuid";
import { filterContextSliceReducer } from "./filterContext";
import { layoutSliceReducer } from "./layout";
import { loadingSliceReducer } from "./loading";
import { savingSliceReducer } from "./saving";
import { insightsSliceReducer } from "./insights";
import { createRootEventEmitter } from "./_infra/rootEventEmitter";
import { rootCommandHandler } from "./_infra/rootCommandHandler";
import { configSliceReducer } from "./config";
import { dateFilterConfigSliceReducer } from "./dateFilterConfig";
import { permissionsSliceReducer } from "./permissions";
import { alertsSliceReducer } from "./alerts";
import { catalogSliceReducer } from "./catalog";
import { call, fork } from "redux-saga/effects";
import { userSliceReducer } from "./user";
import { metaSliceReducer } from "./meta";
import { AllQueryServices } from "../queryServices";
import { executionResultsSliceReducer } from "./executionResults";
import { createQueryProcessingModule } from "./_infra/queryProcessing";
import values from "lodash/values";
import merge from "lodash/merge";
import keyBy from "lodash/keyBy";
import { listedDashboardsSliceReducer } from "./listedDashboards";
import { accessibleDashboardsSliceReducer } from "./accessibleDashboards";
import { backendCapabilitiesSliceReducer } from "./backendCapabilities";
import { drillTargetsReducer } from "./drillTargets";
import { drillSliceReducer } from "./drill";
import { uiSliceReducer } from "./ui";
import { getDashboardContext } from "./_infra/contexts";
var nonSerializableEventsAndCommands = [
    "GDC.DASH/EVT.COMMAND.STARTED",
    "GDC.DASH/EVT.COMMAND.FAILED",
    "GDC.DASH/EVT.QUERY.FAILED",
    "@@GDC.DASH.SAVE_NEW",
    "@@GDC.DASH.SAVE_EXISTING",
    "@@GDC.DASH.SAVE_AS",
    // Execution events have errors, execution definitions etc. in them
    "GDC.DASH/EVT.WIDGET.EXECUTION_STARTED",
    "GDC.DASH/EVT.WIDGET.EXECUTION_SUCCEEDED",
    "GDC.DASH/EVT.WIDGET.EXECUTION_FAILED",
    // Custom events may contain whatever
    "GDC.DASH/CMD.EVENT.TRIGGER",
    // Drill commands & events contain non-serializable dataView
    "GDC.DASH/CMD.DRILL",
    "GDC.DASH/CMD.EXECUTION_RESULT.UPSERT",
    "GDC.DASH/EVT.DRILL.REQUESTED",
    "GDC.DASH/EVT.DRILL.RESOLVED",
    "GDC.DASH/CMD.DRILL.DRILL_DOWN",
    "GDC.DASH/EVT.DRILL.DRILL_DOWN.REQUESTED",
    "GDC.DASH/EVT.DRILL.DRILL_DOWN.RESOLVED",
    "GDC.DASH/CMD.DRILL.DRILL_TO_INSIGHT",
    "GDC.DASH/EVT.DRILL.DRILL_TO_INSIGHT.REQUESTED",
    "GDC.DASH/EVT.DRILL.DRILL_TO_INSIGHT.RESOLVED",
    "GDC.DASH/CMD.DRILL.DRILL_TO_DASHBOARD",
    "GDC.DASH/EVT.DRILL.DRILL_TO_DASHBOARD.REQUESTED",
    "GDC.DASH/EVT.DRILL.DRILL_TO_DASHBOARD.RESOLVED",
    "GDC.DASH/CMD.DRILL.DRILL_TO_ATTRIBUTE_URL",
    "GDC.DASH/EVT.DRILL.DRILL_TO_ATTRIBUTE_URL.REQUESTED",
    "GDC.DASH/EVT.DRILL.DRILL_TO_ATTRIBUTE_URL.RESOLVED",
    "GDC.DASH/CMD.DRILL.DRILL_TO_CUSTOM_URL",
    "GDC.DASH/EVT.DRILL.DRILL_TO_CUSTOM_URL.REQUESTED",
    "GDC.DASH/EVT.DRILL.DRILL_TO_CUSTOM_URL.RESOLVED",
    "GDC.DASH/CMD.DRILL.DRILL_TO_LEGACY_DASHBOARD",
    "GDC.DASH/EVT.DRILL.DRILL_TO_LEGACY_DASHBOARD.REQUESTED",
    "GDC.DASH/EVT.DRILL.DRILL_TO_LEGACY_DASHBOARD.RESOLVED",
    "GDC.DASH/CMD.DRILL.DRILLABLE_ITEMS.CHANGE",
    "GDC.DASH/EVT.DRILL.DRILLABLE_ITEMS.CHANGED",
    "meta/setDrillableItems",
    "layout/updateWidgetIdentities",
    "executionResults/upsertExecutionResult",
    "loadingSlice/setLoadingError",
];
function rootSaga(eventEmitter, commandHandler, queryProcessor, backgroundWorkers) {
    var dashboardContext, backgroundWorkers_1, backgroundWorkers_1_1, worker, e_1_1, e_2;
    var e_1, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, call(getDashboardContext)];
            case 1:
                dashboardContext = _b.sent();
                _b.label = 2;
            case 2:
                _b.trys.push([2, 14, , 15]);
                return [4 /*yield*/, fork(eventEmitter)];
            case 3:
                _b.sent();
                return [4 /*yield*/, fork(commandHandler)];
            case 4:
                _b.sent();
                return [4 /*yield*/, fork(queryProcessor)];
            case 5:
                _b.sent();
                _b.label = 6;
            case 6:
                _b.trys.push([6, 11, 12, 13]);
                backgroundWorkers_1 = __values(backgroundWorkers), backgroundWorkers_1_1 = backgroundWorkers_1.next();
                _b.label = 7;
            case 7:
                if (!!backgroundWorkers_1_1.done) return [3 /*break*/, 10];
                worker = backgroundWorkers_1_1.value;
                return [4 /*yield*/, fork(worker, dashboardContext)];
            case 8:
                _b.sent();
                _b.label = 9;
            case 9:
                backgroundWorkers_1_1 = backgroundWorkers_1.next();
                return [3 /*break*/, 7];
            case 10: return [3 /*break*/, 13];
            case 11:
                e_1_1 = _b.sent();
                e_1 = { error: e_1_1 };
                return [3 /*break*/, 13];
            case 12:
                try {
                    if (backgroundWorkers_1_1 && !backgroundWorkers_1_1.done && (_a = backgroundWorkers_1.return)) _a.call(backgroundWorkers_1);
                }
                finally { if (e_1) throw e_1.error; }
                return [7 /*endfinally*/];
            case 13: return [3 /*break*/, 15];
            case 14:
                e_2 = _b.sent();
                // eslint-disable-next-line no-console
                console.error("Root saga failed", e_2);
                return [3 /*break*/, 15];
            case 15: return [2 /*return*/];
        }
    });
}
/**
 * This middleware ensures that actions occurring in the dashboard have their meta enriched with appropriate
 * information:
 *  - all actions have an acceptedTimestamp - this represents the moment the action was recognized by the redux machinery
 *  - command actions also have a uuid - this is mainly used to implement the undo/redo logic
 *
 * Moving forward, there might be even more types of information added here.
 *
 * Note that for the time-related properties to make sense, this middleware should be registered as the first of all the middlewares if possible.
 */
var actionMetaFillingMiddleware = function () { return function (next) { return function (action) {
    var nowTimestamp = +new Date();
    action.meta = __assign(__assign({}, action.meta), { acceptedTimestamp: nowTimestamp });
    if (action.type.startsWith("GDC.DASH/CMD.")) {
        // see: https://www.reddit.com/r/reactjs/comments/7cfgzr/redux_modifying_action_payload_in_middleware/dppknrh?utm_source=share&utm_medium=web2x&context=3
        action.meta = __assign(__assign({}, action.meta), { uuid: uuidv4() });
    }
    return next(action);
}; }; };
function mergeQueryServices(original, extras) {
    if (extras === void 0) { extras = []; }
    return values(merge({}, keyBy(original, function (service) { return service.name; }), keyBy(extras, function (service) { return service.name; })));
}
/**
 * Creates a new store for a dashboard.
 *
 * @param config - runtime configuration to apply on the middlewares and the store
 */
export function createDashboardStore(config) {
    var _a, _b;
    var queryProcessing = createQueryProcessingModule(mergeQueryServices(AllQueryServices, config.queryServices));
    var sagaMiddleware = createSagaMiddleware({
        context: {
            dashboardContext: config.dashboardContext,
            privateContext: (_a = config.privateContext) !== null && _a !== void 0 ? _a : {},
        },
    });
    var middleware = __spread([
        actionMetaFillingMiddleware
    ], getDefaultMiddleware({
        thunk: false,
        /*
         * All events that fly through the store have the dashboard context in the `ctx` prop. This is
         * for the receiver of the event (who may be well off redux).
         *
         * Additionally, some events - namely those reporting on error scenarios may include the actual
         * error instance in them.
         */
        serializableCheck: {
            ignoredActions: nonSerializableEventsAndCommands,
            // events always include ctx
            // various envelopes allow sending explicit callback functions that will be fired
            // while processing the enveloped content. the envelopes are purely for 'promisification' of
            // command or query handling, they have no impact on state; it is no problem that they
            // have such content in them
            ignoredActionPaths: ["ctx", "onStart", "onError", "onSuccess"],
            ignoredPaths: [
                // drillableItems can be functions (header predicates)
                "drill.drillableItems",
                // executions can have Errors stored, also some decorated execution results are non-serializable too
                "executionResults",
            ],
        },
    }), (config.additionalMiddleware ? [config.additionalMiddleware] : []), [
        sagaMiddleware,
    ]);
    var rootReducer = combineReducers({
        loading: loadingSliceReducer,
        saving: savingSliceReducer,
        backendCapabilities: backendCapabilitiesSliceReducer,
        config: configSliceReducer,
        permissions: permissionsSliceReducer,
        filterContext: filterContextSliceReducer,
        layout: layoutSliceReducer,
        dateFilterConfig: dateFilterConfigSliceReducer,
        insights: insightsSliceReducer,
        alerts: alertsSliceReducer,
        drillTargets: drillTargetsReducer,
        catalog: catalogSliceReducer,
        user: userSliceReducer,
        meta: metaSliceReducer,
        drill: drillSliceReducer,
        listedDashboards: listedDashboardsSliceReducer,
        accessibleDashboards: accessibleDashboardsSliceReducer,
        executionResults: executionResultsSliceReducer,
        ui: uiSliceReducer,
        _queryCache: queryProcessing.queryCacheReducer,
    });
    var store = configureStore({
        reducer: enableBatching(rootReducer),
        middleware: middleware,
    });
    var _c = config.eventing, eventing = _c === void 0 ? {} : _c;
    if (eventing.onStateChange) {
        store.subscribe(function () { var _a; return (_a = eventing.onStateChange) === null || _a === void 0 ? void 0 : _a.call(eventing, store.getState(), store.dispatch); });
    }
    var rootEventEmitter = createRootEventEmitter(eventing.initialEventHandlers, store.dispatch);
    (_b = eventing.onEventingInitialized) === null || _b === void 0 ? void 0 : _b.call(eventing, rootEventEmitter.registerHandler, rootEventEmitter.unregisterHandler);
    var rootSagaTask = sagaMiddleware.run(rootSaga, rootEventEmitter.eventEmitterSaga, rootCommandHandler, queryProcessing.rootQueryProcessor, config.backgroundWorkers);
    return {
        store: store,
        registerEventHandler: rootEventEmitter.registerHandler,
        unregisterEventHandler: rootEventEmitter.unregisterHandler,
        rootSagaTask: rootSagaTask,
    };
}
//# sourceMappingURL=dashboardStore.js.map