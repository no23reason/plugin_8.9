import { __assign, __values } from "tslib";
// (C) 2021-2022 GoodData Corporation
import { createSelector } from "@reduxjs/toolkit";
import { objRefToString } from "@gooddata/sdk-model";
import invariant from "ts-invariant";
import { isInsightWidget, isKpiWidget, } from "@gooddata/sdk-backend-spi";
import { isCustomWidget } from "../../types/layoutTypes";
import { createUndoableCommandsMapping } from "../_infra/undoEnhancer";
import { newMapForObjectWithIdentity } from "../../../_staging/metadata/objRefMap";
import { selectFilterContextFilters } from "../filterContext/filterContextSelectors";
import { filterContextItemsToDashboardFiltersByWidget } from "../../../converters";
import { createMemoizedSelector } from "../_infra/selectors";
import isEmpty from "lodash/isEmpty";
var selectSelf = createSelector(function (state) { return state; }, function (state) { return state.layout; });
/**
 * This selector returns current layout's stash. This stash can contain items that were removed from the layout with the
 * intent of further using the item elsewhere on the layout. The stash is a mapping of stashIdentifier to an array
 * of stashed items. The stash identifiers and stash usage is fully under control of the user.
 *
 * @internal
 */
export var selectStash = createSelector(selectSelf, function (layoutState) {
    return layoutState.stash;
});
/**
 * This selector returns commands that impacted the layout and can now be undone.
 *
 * @internal
 */
export var selectUndoableLayoutCommands = createSelector(selectSelf, function (layoutState) {
    return createUndoableCommandsMapping(layoutState);
});
/**
 * This selector returns dashboard's layout. It is expected that the selector is called only after the layout state
 * is correctly initialized. Invocations before initialization lead to invariant errors.
 *
 * @alpha
 */
export var selectLayout = createSelector(selectSelf, function (layoutState) {
    invariant(layoutState.layout, "attempting to access uninitialized layout state");
    return layoutState.layout;
});
function isItemWithBaseWidget(obj) {
    var widget = obj.widget;
    return isInsightWidget(widget) || isKpiWidget(widget);
}
/**
 * This selector returns the basic dashboard layout that does not contain any client-side extensions.
 *
 * This selector exists because analytical backend impls are not yet ready to handle persistence of custom
 * widgets (that may have arbitrary payloads). The selector is used only in save and saveAs command handlers,
 * where it obtains the layout without any custom widgets and persists that. Note that the save/saveAs
 * handlers will not wipe the custom widgets from the state during the save - so at this point the custom
 * widgets are treated as client-side extensions.
 *
 * Note: this selector also intentionally removes empty sections; dashboard cannot cope with them and
 * they may readily appear if user adds section full of custom widgets and then does saveAs; such sections
 * would end up empty.
 *
 * @internal
 */
export var selectBasicLayout = createSelector(selectLayout, function (layout) {
    var dashboardLayout = __assign(__assign({}, layout), { sections: layout.sections
            .map(function (section) {
            return __assign(__assign({}, section), { items: section.items.filter(isItemWithBaseWidget) });
        })
            .filter(function (section) { return !isEmpty(section.items); }) });
    return dashboardLayout;
});
/**
 * Selects dashboard widgets in an obj ref to widget map. This map will include both analytical and custom
 * widgets that are placed on the dashboard.
 *
 * @internal
 */
export var selectWidgetsMap = createSelector(selectLayout, function (layout) {
    var e_1, _a, e_2, _b;
    var items = [];
    try {
        for (var _c = __values(layout.sections), _d = _c.next(); !_d.done; _d = _c.next()) {
            var section = _d.value;
            try {
                for (var _e = (e_2 = void 0, __values(section.items)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var item = _f.value;
                    if (!item.widget) {
                        continue;
                    }
                    items.push(item.widget);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return newMapForObjectWithIdentity(items);
});
/**
 * Selects widget by its ref (including custom widgets).
 *
 * @remarks
 * To limit the scope only to analytical widgets, use {@link selectAnalyticalWidgetByRef}.
 *
 * @alpha
 */
export var selectWidgetByRef = createMemoizedSelector(function (ref) {
    return createSelector(selectWidgetsMap, function (widgetMap) {
        if (!ref) {
            return undefined;
        }
        return widgetMap.get(ref);
    });
});
/**
 * Selects analytical widget by its ref. This selector will return undefined if the provided
 * widget ref is for a custom widget.
 *
 * @remarks
 * To include custom widgets as well, use {@link selectWidgetByRef}.
 *
 * @alpha
 */
export var selectAnalyticalWidgetByRef = createMemoizedSelector(function (ref) {
    return createSelector(selectWidgetsMap, function (widgetMap) {
        if (!ref) {
            return undefined;
        }
        var widget = widgetMap.get(ref);
        if (!widget || isCustomWidget(widget)) {
            return undefined;
        }
        return widget;
    });
});
/**
 * Selects widget drills by the widget ref.
 *
 * @alpha
 */
export var selectWidgetDrills = createMemoizedSelector(function (ref) {
    return createSelector(selectAnalyticalWidgetByRef(ref), function (widget) { var _a; return (_a = widget === null || widget === void 0 ? void 0 : widget.drills) !== null && _a !== void 0 ? _a : []; });
});
/**
 * Selects all filters from filter context converted to filters specific for a widget specified by a ref.
 *
 * @remarks
 * This does NOT resolve things like ignored filters for a widget, etc.
 *
 * @internal
 */
export var selectAllFiltersForWidgetByRef = createMemoizedSelector(function (ref) {
    return createSelector(selectWidgetByRef(ref), selectFilterContextFilters, function (widget, dashboardFilters) {
        invariant(widget, "widget with ref " + objRefToString(ref) + " does not exist in the state");
        return filterContextItemsToDashboardFiltersByWidget(dashboardFilters, widget);
    });
});
var selectAllWidgets = createSelector(selectWidgetsMap, function (widgetMap) {
    return Array.from(widgetMap.values());
});
/**
 * Selects a boolean indicating if the dashboard is empty.
 *
 * @alpha
 */
export var selectIsLayoutEmpty = createSelector(selectAllWidgets, function (allWidgets) {
    return allWidgets.length === 0;
});
/**
 * Selects all KPI widgets in the layout.
 *
 * @alpha
 */
export var selectAllKpiWidgets = createSelector(selectAllWidgets, function (allWidgets) {
    return allWidgets.filter(isKpiWidget);
});
/**
 * Selects all insight widgets in the layout.
 *
 * @alpha
 */
export var selectAllInsightWidgets = createSelector(selectAllWidgets, function (allWidgets) {
    return allWidgets.filter(isInsightWidget);
});
/**
 * Selects all custom widgets in the layout.
 *
 * @alpha
 */
export var selectAllCustomWidgets = createSelector(selectAllWidgets, function (allWidgets) {
    return allWidgets.filter(isCustomWidget);
});
//# sourceMappingURL=layoutSelectors.js.map