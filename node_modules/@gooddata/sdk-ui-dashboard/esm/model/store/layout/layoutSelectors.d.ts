import { ObjRef } from "@gooddata/sdk-model";
import { DashboardState } from "../types";
import { LayoutState } from "./layoutState";
import { IDashboardLayout, IWidget } from "@gooddata/sdk-backend-spi";
import { ExtendedDashboardWidget } from "../../types/layoutTypes";
/**
 * This selector returns current layout's stash. This stash can contain items that were removed from the layout with the
 * intent of further using the item elsewhere on the layout. The stash is a mapping of stashIdentifier to an array
 * of stashed items. The stash identifiers and stash usage is fully under control of the user.
 *
 * @internal
 */
export declare const selectStash: import("@reduxjs/toolkit").OutputSelector<DashboardState, Record<string, import("../../types/layoutTypes").ExtendedDashboardItem<ExtendedDashboardWidget>[]>, (res: LayoutState) => Record<string, import("../../types/layoutTypes").ExtendedDashboardItem<ExtendedDashboardWidget>[]>>;
/**
 * This selector returns commands that impacted the layout and can now be undone.
 *
 * @internal
 */
export declare const selectUndoableLayoutCommands: import("@reduxjs/toolkit").OutputSelector<DashboardState, import("../_infra/undoEnhancer").UndoableCommand<import("../..").DashboardLayoutCommands>[], (res: LayoutState) => import("../_infra/undoEnhancer").UndoableCommand<import("../..").DashboardLayoutCommands>[]>;
/**
 * This selector returns dashboard's layout. It is expected that the selector is called only after the layout state
 * is correctly initialized. Invocations before initialization lead to invariant errors.
 *
 * @alpha
 */
export declare const selectLayout: import("@reduxjs/toolkit").OutputSelector<DashboardState, IDashboardLayout<ExtendedDashboardWidget>, (res: LayoutState) => IDashboardLayout<ExtendedDashboardWidget>>;
/**
 * This selector returns the basic dashboard layout that does not contain any client-side extensions.
 *
 * This selector exists because analytical backend impls are not yet ready to handle persistence of custom
 * widgets (that may have arbitrary payloads). The selector is used only in save and saveAs command handlers,
 * where it obtains the layout without any custom widgets and persists that. Note that the save/saveAs
 * handlers will not wipe the custom widgets from the state during the save - so at this point the custom
 * widgets are treated as client-side extensions.
 *
 * Note: this selector also intentionally removes empty sections; dashboard cannot cope with them and
 * they may readily appear if user adds section full of custom widgets and then does saveAs; such sections
 * would end up empty.
 *
 * @internal
 */
export declare const selectBasicLayout: import("@reduxjs/toolkit").OutputSelector<DashboardState, IDashboardLayout<IWidget>, (res: IDashboardLayout<ExtendedDashboardWidget>) => IDashboardLayout<IWidget>>;
/**
 * Selects dashboard widgets in an obj ref to widget map. This map will include both analytical and custom
 * widgets that are placed on the dashboard.
 *
 * @internal
 */
export declare const selectWidgetsMap: import("@reduxjs/toolkit").OutputSelector<DashboardState, import("../../../_staging/metadata/objRefMap").ObjRefMap<ExtendedDashboardWidget>, (res: IDashboardLayout<ExtendedDashboardWidget>) => import("../../../_staging/metadata/objRefMap").ObjRefMap<ExtendedDashboardWidget>>;
/**
 * Selects widget by its ref (including custom widgets).
 *
 * @remarks
 * To limit the scope only to analytical widgets, use {@link selectAnalyticalWidgetByRef}.
 *
 * @alpha
 */
export declare const selectWidgetByRef: (ref: ObjRef | undefined) => import("@reduxjs/toolkit").OutputSelector<DashboardState, import("@gooddata/sdk-backend-spi").IKpiWidget | import("@gooddata/sdk-backend-spi").IInsightWidget | import("../../types/layoutTypes").ICustomWidget | undefined, (res: import("../../../_staging/metadata/objRefMap").ObjRefMap<ExtendedDashboardWidget>) => import("@gooddata/sdk-backend-spi").IKpiWidget | import("@gooddata/sdk-backend-spi").IInsightWidget | import("../../types/layoutTypes").ICustomWidget | undefined>;
/**
 * Selects analytical widget by its ref. This selector will return undefined if the provided
 * widget ref is for a custom widget.
 *
 * @remarks
 * To include custom widgets as well, use {@link selectWidgetByRef}.
 *
 * @alpha
 */
export declare const selectAnalyticalWidgetByRef: (ref: ObjRef | undefined) => import("@reduxjs/toolkit").OutputSelector<DashboardState, import("@gooddata/sdk-backend-spi").IKpiWidget | import("@gooddata/sdk-backend-spi").IInsightWidget | undefined, (res: import("../../../_staging/metadata/objRefMap").ObjRefMap<ExtendedDashboardWidget>) => import("@gooddata/sdk-backend-spi").IKpiWidget | import("@gooddata/sdk-backend-spi").IInsightWidget | undefined>;
/**
 * Selects widget drills by the widget ref.
 *
 * @alpha
 */
export declare const selectWidgetDrills: (ref: ObjRef | undefined) => import("@reduxjs/toolkit").OutputSelector<DashboardState, import("@gooddata/sdk-backend-spi").IDrillToLegacyDashboard[] | import("@gooddata/sdk-backend-spi").InsightDrillDefinition[], (res: import("@gooddata/sdk-backend-spi").IKpiWidget | import("@gooddata/sdk-backend-spi").IInsightWidget | undefined) => import("@gooddata/sdk-backend-spi").IDrillToLegacyDashboard[] | import("@gooddata/sdk-backend-spi").InsightDrillDefinition[]>;
/**
 * Selects all filters from filter context converted to filters specific for a widget specified by a ref.
 *
 * @remarks
 * This does NOT resolve things like ignored filters for a widget, etc.
 *
 * @internal
 */
export declare const selectAllFiltersForWidgetByRef: (ref: ObjRef) => import("@reduxjs/toolkit").OutputSelector<DashboardState, (import("@gooddata/sdk-model").IPositiveAttributeFilter | import("@gooddata/sdk-model").INegativeAttributeFilter | import("@gooddata/sdk-model").IAbsoluteDateFilter | {
    relativeDateFilter: {
        dataSet: ObjRef;
        granularity: import("@gooddata/sdk-model").DateAttributeGranularity;
        from: number;
        to: number;
    };
} | {
    relativeDateFilter: {
        dataSet: ObjRef;
        granularity: "ALL_TIME_GRANULARITY";
        from: 0;
        to: 0;
    };
})[], (res1: import("@gooddata/sdk-backend-spi").IKpiWidget | import("@gooddata/sdk-backend-spi").IInsightWidget | import("../../types/layoutTypes").ICustomWidget | undefined, res2: import("@gooddata/sdk-backend-spi").FilterContextItem[]) => (import("@gooddata/sdk-model").IPositiveAttributeFilter | import("@gooddata/sdk-model").INegativeAttributeFilter | import("@gooddata/sdk-model").IAbsoluteDateFilter | {
    relativeDateFilter: {
        dataSet: ObjRef;
        granularity: import("@gooddata/sdk-model").DateAttributeGranularity;
        from: number;
        to: number;
    };
} | {
    relativeDateFilter: {
        dataSet: ObjRef;
        granularity: "ALL_TIME_GRANULARITY";
        from: 0;
        to: 0;
    };
})[]>;
/**
 * Selects a boolean indicating if the dashboard is empty.
 *
 * @alpha
 */
export declare const selectIsLayoutEmpty: import("@reduxjs/toolkit").OutputSelector<DashboardState, boolean, (res: ExtendedDashboardWidget[]) => boolean>;
/**
 * Selects all KPI widgets in the layout.
 *
 * @alpha
 */
export declare const selectAllKpiWidgets: import("@reduxjs/toolkit").OutputSelector<DashboardState, import("@gooddata/sdk-backend-spi").IKpiWidget[], (res: ExtendedDashboardWidget[]) => import("@gooddata/sdk-backend-spi").IKpiWidget[]>;
/**
 * Selects all insight widgets in the layout.
 *
 * @alpha
 */
export declare const selectAllInsightWidgets: import("@reduxjs/toolkit").OutputSelector<DashboardState, import("@gooddata/sdk-backend-spi").IInsightWidget[], (res: ExtendedDashboardWidget[]) => import("@gooddata/sdk-backend-spi").IInsightWidget[]>;
/**
 * Selects all custom widgets in the layout.
 *
 * @alpha
 */
export declare const selectAllCustomWidgets: import("@reduxjs/toolkit").OutputSelector<DashboardState, import("../../types/layoutTypes").ICustomWidget[], (res: ExtendedDashboardWidget[]) => import("../../types/layoutTypes").ICustomWidget[]>;
//# sourceMappingURL=layoutSelectors.d.ts.map