// (C) 2021-2022 GoodData Corporation
import { __awaiter, __generator, __read, __spread } from "tslib";
import { isInsight, isObjRef } from "@gooddata/sdk-model";
import { call, select } from "redux-saga/effects";
import { selectInsightsMap } from "../store/insights/insightsSelectors";
import { newInsightMap } from "../../_staging/metadata/objRefMap";
function loadInsightsFromBackend(ctx, insightRefs) {
    return __awaiter(this, void 0, void 0, function () {
        var backend, workspace, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    backend = ctx.backend, workspace = ctx.workspace;
                    return [4 /*yield*/, Promise.all(insightRefs.map(function (ref) {
                            return backend
                                .workspace(workspace)
                                .insights()
                                .getInsight(ref)
                                .catch(function (_) { return ref; });
                        }))];
                case 1:
                    result = _a.sent();
                    return [2 /*return*/, {
                            loaded: result.filter(isInsight),
                            missing: result.filter(isObjRef),
                        }];
            }
        });
    });
}
/**
 * Given a list of insight ObjRefs, this generator will resolve those refs to actual IInsight objects. The resolution
 * is done from two sources: first the insights already stored in the lazily-populated insight slice, second, as a fallback
 * the actual analytical backend.
 *
 * @param ctx - dashboard context in which the resolution is done
 * @param insightRefs - refs of insights to resolve to IInsight
 */
export function resolveInsights(ctx, insightRefs) {
    var alreadyLoadedInsights, foundInsights, missingInsightRefs, loadResult;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, select(selectInsightsMap)];
            case 1:
                alreadyLoadedInsights = _a.sent();
                foundInsights = [];
                missingInsightRefs = [];
                insightRefs.forEach(function (ref) {
                    var insight = alreadyLoadedInsights.get(ref);
                    if (insight) {
                        foundInsights.push(insight);
                    }
                    else {
                        missingInsightRefs.push(ref);
                    }
                });
                return [4 /*yield*/, call(loadInsightsFromBackend, ctx, missingInsightRefs)];
            case 2:
                loadResult = _a.sent();
                return [2 /*return*/, {
                        resolved: newInsightMap(__spread(foundInsights, loadResult.loaded)),
                        loaded: loadResult.loaded,
                        missing: loadResult.missing,
                    }];
        }
    });
}
//# sourceMappingURL=insightResolver.js.map