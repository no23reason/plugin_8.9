import { __assign, __generator, __read } from "tslib";
import { all, call } from "redux-saga/effects";
import { defaultDateFilterConfig } from "../../../../_staging/dateFilterConfig/defaultConfig";
import { getValidDateFilterConfig } from "../../../../_staging/dateFilterConfig/validation";
import { stripUserAndWorkspaceProps } from "../../../../_staging/settings/conversion";
import { dateFilterValidationFailed } from "../../../events/dashboard";
import { dispatchDashboardEvent } from "../../../store/_infra/eventDispatcher";
import { isResolvedConfig, } from "../../../types/commonTypes";
import { sanitizeUnfinishedFeatureSettings } from "./sanitizeUnfinishedFeatureSettings";
function loadDateFilterConfig(ctx) {
    var backend = ctx.backend, workspace = ctx.workspace;
    return backend
        .workspace(workspace)
        .dateFilterConfigs()
        .withLimit(1)
        .query()
        .catch(function (e) {
        // eslint-disable-next-line no-console
        console.log("An error has occurred while loading date filter config. Will fall back to default date filter config.", e);
        return undefined;
    });
}
function loadSettingsForCurrentUser(ctx) {
    var backend = ctx.backend, workspace = ctx.workspace;
    return backend.workspace(workspace).settings().getSettingsForCurrentUser();
}
function loadColorPalette(ctx) {
    var backend = ctx.backend, workspace = ctx.workspace;
    return backend.workspace(workspace).styling().getColorPalette();
}
function resolveDateFilterConfig(ctx, config, cmd) {
    var result, firstConfig;
    var _a, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                if (config.dateFilterConfig !== undefined) {
                    return [2 /*return*/, config.dateFilterConfig];
                }
                return [4 /*yield*/, call(loadDateFilterConfig, ctx)];
            case 1:
                result = _c.sent();
                if (!(((_a = result === null || result === void 0 ? void 0 : result.totalCount) !== null && _a !== void 0 ? _a : 0) > 1)) return [3 /*break*/, 3];
                return [4 /*yield*/, dispatchDashboardEvent(dateFilterValidationFailed(ctx, "TOO_MANY_CONFIGS", cmd.correlationId))];
            case 2:
                _c.sent();
                _c.label = 3;
            case 3:
                firstConfig = result === null || result === void 0 ? void 0 : result.items[0];
                if (!!firstConfig) return [3 /*break*/, 5];
                return [4 /*yield*/, dispatchDashboardEvent(dateFilterValidationFailed(ctx, "NO_CONFIG", cmd.correlationId))];
            case 4:
                _c.sent();
                _c.label = 5;
            case 5: return [2 /*return*/, (_b = result === null || result === void 0 ? void 0 : result.items[0]) !== null && _b !== void 0 ? _b : defaultDateFilterConfig];
        }
    });
}
function resolveUserSettings(ctx, config) {
    if (config.settings && config.locale && config.separators) {
        return Promise.resolve({
            locale: config.locale,
            separators: config.separators,
            settings: config.settings,
        });
    }
    return loadSettingsForCurrentUser(ctx).then(function (res) {
        var _a, _b, _c;
        return ({
            locale: (_a = config.locale) !== null && _a !== void 0 ? _a : res.locale,
            separators: (_b = config.separators) !== null && _b !== void 0 ? _b : res.separators,
            settings: (_c = config.settings) !== null && _c !== void 0 ? _c : stripUserAndWorkspaceProps(res),
        });
    });
}
function resolveColorPalette(ctx, config) {
    if (config.colorPalette) {
        return Promise.resolve(config.colorPalette);
    }
    return loadColorPalette(ctx);
}
/**
 * Loads all essential dashboard configuration from the backend if needed. The load command may specify their
 * own inline config - if that is the case the config is bounced back immediately. Otherwise the necessary
 * backend queries and post-processing is done.
 */
export function resolveDashboardConfig(ctx, cmd) {
    var _a, config, _b, dateFilterConfig, settings, colorPalette, _c, validDateFilterConfig, configValidation, allowUnfinishedFeatures, resolvedConfig;
    var _d, _e, _f, _g, _h, _j, _k, _l;
    return __generator(this, function (_m) {
        switch (_m.label) {
            case 0:
                _a = cmd.payload.config, config = _a === void 0 ? {} : _a;
                if (isResolvedConfig(config)) {
                    /*
                     * Config coming in props is fully specified. There is nothing to do. Bail out immediately.
                     */
                    if (config.allowUnfinishedFeatures || !config.settings) {
                        return [2 /*return*/, config];
                    }
                    return [2 /*return*/, __assign(__assign({}, config), { settings: sanitizeUnfinishedFeatureSettings(config.settings) })];
                }
                return [4 /*yield*/, all([
                        call(resolveDateFilterConfig, ctx, config, cmd),
                        call(resolveUserSettings, ctx, config),
                        call(resolveColorPalette, ctx, config),
                    ])];
            case 1:
                _b = __read.apply(void 0, [_m.sent(), 3]), dateFilterConfig = _b[0], settings = _b[1], colorPalette = _b[2];
                _c = __read(getValidDateFilterConfig(dateFilterConfig, settings.settings), 2), validDateFilterConfig = _c[0], configValidation = _c[1];
                if (!(configValidation !== "Valid")) return [3 /*break*/, 3];
                return [4 /*yield*/, dispatchDashboardEvent(dateFilterValidationFailed(ctx, configValidation, cmd.correlationId))];
            case 2:
                _m.sent();
                _m.label = 3;
            case 3:
                allowUnfinishedFeatures = (_d = config.allowUnfinishedFeatures) !== null && _d !== void 0 ? _d : false;
                resolvedConfig = {
                    locale: settings.locale,
                    separators: settings.separators,
                    dateFilterConfig: validDateFilterConfig,
                    settings: allowUnfinishedFeatures
                        ? settings.settings
                        : sanitizeUnfinishedFeatureSettings(settings.settings),
                    colorPalette: colorPalette,
                    objectAvailability: (_e = config.objectAvailability) !== null && _e !== void 0 ? _e : {},
                    mapboxToken: config.mapboxToken,
                    isReadOnly: (_f = config.isReadOnly) !== null && _f !== void 0 ? _f : false,
                    isEmbedded: (_g = config.isEmbedded) !== null && _g !== void 0 ? _g : false,
                    isExport: (_h = config.isExport) !== null && _h !== void 0 ? _h : false,
                    disableDefaultDrills: (_j = config.disableDefaultDrills) !== null && _j !== void 0 ? _j : false,
                    enableFilterValuesResolutionInDrillEvents: (_k = config.enableFilterValuesResolutionInDrillEvents) !== null && _k !== void 0 ? _k : false,
                    menuButtonItemsVisibility: (_l = config.menuButtonItemsVisibility) !== null && _l !== void 0 ? _l : {},
                    allowUnfinishedFeatures: allowUnfinishedFeatures,
                };
                return [2 /*return*/, resolvedConfig];
        }
    });
}
//# sourceMappingURL=resolveDashboardConfig.js.map