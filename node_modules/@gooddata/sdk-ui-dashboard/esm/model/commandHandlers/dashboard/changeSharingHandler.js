import { __assign, __generator, __rest } from "tslib";
import { call, put, select } from "redux-saga/effects";
import { isFilterContext } from "@gooddata/sdk-backend-spi";
import { dashboardSharingChanged } from "../../events/dashboard";
import { selectDashboardRef, selectPersistedDashboard } from "../../store/meta/metaSelectors";
import { invalidArgumentsProvided } from "../../events/general";
import { metaActions } from "../../store/meta";
import { batchActions } from "redux-batched-actions";
import invariant from "ts-invariant";
import isEmpty from "lodash/isEmpty";
function createDashboardSaveSharingContext(cmd) {
    var newSharingProperties, persistedDashboard, filterContext, otherDashboardProps, filterContextProp, dashboardFromState, dashboardToSave;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                newSharingProperties = cmd.payload.newSharingProperties;
                return [4 /*yield*/, select(selectPersistedDashboard)];
            case 1:
                persistedDashboard = _a.sent();
                invariant(persistedDashboard, "Cant change sharing of unsaved dashboard");
                filterContext = persistedDashboard.filterContext, otherDashboardProps = __rest(persistedDashboard, ["filterContext"]);
                filterContextProp = isFilterContext(filterContext)
                    ? {
                        filterContext: filterContext,
                    }
                    : {};
                dashboardFromState = __assign(__assign({}, otherDashboardProps), filterContextProp);
                dashboardToSave = __assign(__assign({}, dashboardFromState), newSharingProperties);
                return [2 /*return*/, {
                        cmd: cmd,
                        persistedDashboard: persistedDashboard,
                        dashboardToSave: dashboardToSave,
                    }];
        }
    });
}
function updateDashboard(ctx, saveSharingCtx) {
    return ctx.backend
        .workspace(ctx.workspace)
        .dashboards()
        .updateDashboard(saveSharingCtx.persistedDashboard, saveSharingCtx.dashboardToSave);
}
function addGrantees(ctx, saveSharingCtx) {
    var cmd = saveSharingCtx.cmd;
    return ctx.backend
        .workspace(ctx.workspace)
        .accessControl()
        .grantAccess(ctx.dashboardRef, cmd.payload.newSharingProperties.granteesToAdd);
}
function removeGrantees(ctx, saveSharingCtx) {
    var cmd = saveSharingCtx.cmd;
    return ctx.backend
        .workspace(ctx.workspace)
        .accessControl()
        .revokeAccess(ctx.dashboardRef, cmd.payload.newSharingProperties.granteesToDelete);
}
function saveSharing(ctx, saveSharingCtx) {
    var dashboard, _a, granteesToDelete, granteesToAdd, batch;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, call(updateDashboard, ctx, saveSharingCtx)];
            case 1:
                dashboard = _b.sent();
                _a = saveSharingCtx.cmd.payload.newSharingProperties, granteesToDelete = _a.granteesToDelete, granteesToAdd = _a.granteesToAdd;
                if (!!isEmpty(granteesToDelete)) return [3 /*break*/, 3];
                return [4 /*yield*/, call(removeGrantees, ctx, saveSharingCtx)];
            case 2:
                _b.sent();
                _b.label = 3;
            case 3:
                if (!!isEmpty(granteesToAdd)) return [3 /*break*/, 5];
                return [4 /*yield*/, call(addGrantees, ctx, saveSharingCtx)];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                batch = batchActions([metaActions.setMeta({ dashboard: dashboard })], "@@GDC.DASH.SAVE_SHARING");
                return [2 /*return*/, {
                        batch: batch,
                        dashboard: dashboard,
                    }];
        }
    });
}
export function changeSharingHandler(ctx, cmd) {
    var dashboardRef, saveSharingCtx, result, batch;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, select(selectDashboardRef)];
            case 1:
                dashboardRef = _a.sent();
                if (!dashboardRef) {
                    throw invalidArgumentsProvided(ctx, cmd, "Dashboard to change its sharing status must have an ObjRef.");
                }
                return [4 /*yield*/, call(createDashboardSaveSharingContext, cmd)];
            case 2:
                saveSharingCtx = _a.sent();
                return [4 /*yield*/, call(saveSharing, ctx, saveSharingCtx)];
            case 3:
                result = _a.sent();
                batch = result.batch;
                if (!batch) return [3 /*break*/, 5];
                return [4 /*yield*/, put(batch)];
            case 4:
                _a.sent();
                _a.label = 5;
            case 5: return [2 /*return*/, dashboardSharingChanged(ctx, dashboardRef, cmd.payload.newSharingProperties, cmd.correlationId)];
        }
    });
}
//# sourceMappingURL=changeSharingHandler.js.map