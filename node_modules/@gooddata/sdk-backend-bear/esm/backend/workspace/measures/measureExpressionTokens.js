import { __assign } from "tslib";
// (C) 2019-2022 GoodData Corporation
import flow from "lodash/flow";
import filter from "lodash/fp/filter";
import map from "lodash/fp/map";
import uniq from "lodash/fp/uniq";
var REMOVE_BRACKETS_REGEXP = /[[\]{}]/g;
var TOKEN_TYPE_REGEXP_PAIRS = [
    ["text", /^[^#{}[\]"()0-9.]+/],
    ["quoted_text", /^"(?:[^"\\]|\\\\.)*"/],
    ["number", /^[+-]?((\d+(\.\d*)?)|(\.\d+))/],
    ["bracket", /^[()]+/],
    ["identifier", /^\{[^}]+\}/],
    ["element_uri", /^\[[a-zA-Z0-9\\/]+elements\?id=\d+]/],
    ["uri", /^\[[a-zA-Z0-9\\/]+]/],
    ["comment", /#[^\n]*/],
];
export var getTokenValuesOfType = function (tokenType, tokens) {
    return flow(filter(function (token) { return token.type === tokenType; }), map(function (token) { return token.value; }), uniq)(tokens);
};
export var tokenizeExpression = function (expression) {
    var tokens = [];
    var _expression = expression;
    while (_expression.length) {
        var match = void 0;
        for (var _i = 0, TOKEN_TYPE_REGEXP_PAIRS_1 = TOKEN_TYPE_REGEXP_PAIRS; _i < TOKEN_TYPE_REGEXP_PAIRS_1.length; _i++) {
            var _a = TOKEN_TYPE_REGEXP_PAIRS_1[_i], type = _a[0], regExp = _a[1];
            match = _expression.match(regExp);
            if (match) {
                var value = match[0];
                tokens.push({ type: type, value: value });
                _expression = _expression.substr(value.length);
                break;
            }
        }
        if (!match) {
            throw new Error("Unable to match token, rest of output is: \"" + _expression + "\"");
        }
    }
    return tokens.map(function (token) { return (__assign(__assign({}, token), { value: token.type === "comment" ? token.value : token.value.replace(REMOVE_BRACKETS_REGEXP, "") })); });
};
//# sourceMappingURL=measureExpressionTokens.js.map