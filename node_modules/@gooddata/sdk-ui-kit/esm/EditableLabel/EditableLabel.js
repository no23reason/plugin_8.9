import { __extends } from "tslib";
// (C) 2007-2022 GoodData Corporation
import React, { Component } from "react";
import { v4 as uuid } from "uuid";
import identity from "lodash/identity";
import TextareaAutosize from "react-textarea-autosize";
import cx from "classnames";
import { Overlay } from "../Overlay";
import { ENUM_KEY_CODE } from "../typings/utilities";
/**
 * @internal
 */
var EditableLabel = /** @class */ (function (_super) {
    __extends(EditableLabel, _super);
    function EditableLabel(props) {
        var _this = _super.call(this, props) || this;
        _this.onDocumentClick = function (e) {
            if (_this.isClickOutsideTextarea(e.target)) {
                var textAreaNode = _this.textarea.current;
                textAreaNode.blur();
            }
        };
        _this.onKeyDown = function (e) {
            var isSubmit = e.keyCode === ENUM_KEY_CODE.KEY_CODE_ENTER;
            var isCancel = e.keyCode === ENUM_KEY_CODE.KEY_CODE_ESCAPE;
            if (isSubmit || isCancel) {
                e.preventDefault();
                e.stopPropagation();
            }
            if (isSubmit) {
                _this.onSubmit();
            }
            if (isCancel) {
                _this.onCancel();
            }
        };
        _this.onSubmit = function () {
            var oldValue = _this.props.value;
            var newTrimmedValue = _this.state.value.trim();
            if (newTrimmedValue === "") {
                _this.setState({
                    value: "",
                });
            }
            if (oldValue !== newTrimmedValue) {
                _this.props.onSubmit(newTrimmedValue);
            }
            else {
                _this.props.onCancel(oldValue);
            }
            _this.setState({
                value: newTrimmedValue,
                isEditing: false,
            });
            _this.removeListeners();
        };
        _this.onCancel = function () {
            var value = _this.props.value;
            _this.props.onCancel(value);
            _this.setState({
                value: value,
                isEditing: false,
            });
            _this.removeListeners();
        };
        _this.onChange = function (e) {
            var value = e.target.value;
            _this.setState({ value: value }, function () {
                _this.props.onChange(value);
            });
        };
        _this.edit = function (e) {
            if (!_this.state.isEditing) {
                if (e) {
                    e.stopPropagation();
                }
                _this.setState({
                    isEditing: true,
                }, function () {
                    _this.selectAndFocus();
                    document.addEventListener("mousedown", _this.onDocumentClick);
                });
                _this.props.onEditingStart();
            }
        };
        _this.selectAndFocus = function () {
            var componentElement = _this.textarea.current;
            var _a = _this.props, scrollToEndOnEditingStart = _a.scrollToEndOnEditingStart, textareaInOverlay = _a.textareaInOverlay;
            if (componentElement) {
                componentElement.focus();
                if (scrollToEndOnEditingStart && _this.isMultiLine()) {
                    componentElement.scrollTop = componentElement.scrollHeight;
                }
                componentElement.select();
                if (textareaInOverlay) {
                    _this.measureRootDimensions();
                }
            }
        };
        _this.state = {
            value: props.value,
            isEditing: false,
            textareaWidth: 100,
        };
        _this.root = React.createRef();
        _this.textarea = React.createRef();
        return _this;
    }
    EditableLabel.prototype.componentDidMount = function () {
        var rootNode = this.root.current;
        rootNode.addEventListener("dragstart", this.onSelectStart);
        rootNode.addEventListener("selectstart", this.onSelectStart);
        if (this.props.autofocus) {
            this.edit();
        }
    };
    EditableLabel.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {
        if (this.props.value !== newProps.value) {
            this.setState({
                value: newProps.value,
            });
        }
    };
    EditableLabel.prototype.componentWillUnmount = function () {
        var rootNode = this.root.current;
        rootNode.removeEventListener("dragstart", this.onSelectStart);
        rootNode.removeEventListener("selectstart", this.onSelectStart);
        this.removeListeners();
    };
    EditableLabel.prototype.onSelectStart = function (e) {
        e.stopPropagation();
    };
    EditableLabel.prototype.isClickOutsideTextarea = function (clickedTarget) {
        return this.textarea.current && !this.textarea.current.contains(clickedTarget);
    };
    EditableLabel.prototype.isMultiLine = function () {
        return this.props.maxRows > 1;
    };
    EditableLabel.prototype.removeListeners = function () {
        document.removeEventListener("mousedown", this.onDocumentClick);
    };
    EditableLabel.prototype.measureRootDimensions = function () {
        var rootElement = this.root.current;
        var rootElementFontSize = getComputedStyle(rootElement).fontSize;
        this.setState({
            textareaWidth: rootElement.offsetWidth,
            textareaFontSize: Math.floor(parseInt(rootElementFontSize, 10)),
        });
    };
    EditableLabel.prototype.renderTextAreaInOverlay = function () {
        var alignId = "gd-editable-label-" + uuid();
        var style = {
            width: this.state.textareaWidth,
            fontSize: this.state.textareaFontSize + "px",
            // http://stackoverflow.com/a/6295222
            lineHeight: this.state.textareaFontSize * 1.25 + "px",
        };
        return (React.createElement("div", { className: alignId + " gd-editable-label-textarea-wrapper" },
            React.createElement(Overlay, { alignTo: "." + alignId, alignPoints: [
                    {
                        align: "cr cr",
                    },
                ] },
                React.createElement("div", { className: "gd-editable-label-overlay" }, this.renderTextarea(style)))));
    };
    EditableLabel.prototype.renderTextarea = function (style) {
        if (style === void 0) { style = {}; }
        return (React.createElement(TextareaAutosize, { style: style, rows: 1, maxRows: this.props.maxRows, maxLength: this.props.maxLength, onKeyDown: this.onKeyDown, onBlur: this.onSubmit, onChange: this.onChange, defaultValue: this.props.value, placeholder: this.props.placeholder, ref: this.textarea }));
    };
    EditableLabel.prototype.renderEditableLabelEdit = function () {
        return this.props.textareaInOverlay ? this.renderTextAreaInOverlay() : this.renderTextarea();
    };
    EditableLabel.prototype.render = function () {
        var editableLabelClasses = cx({
            "gd-editable-label": true,
            "s-editable-label": true,
            "is-editing": this.state.isEditing,
            placeholder: this.state.value === "",
        }, this.props.className);
        var displayValue = this.props.children || this.state.value || this.props.placeholder;
        return (React.createElement("div", { ref: this.root, className: editableLabelClasses, onClick: this.edit }, this.state.isEditing ? this.renderEditableLabelEdit() : displayValue));
    };
    EditableLabel.defaultProps = {
        children: false,
        className: "",
        maxLength: 100000,
        maxRows: 1,
        onCancel: identity,
        onEditingStart: identity,
        onChange: identity,
        placeholder: "",
        scrollToEndOnEditingStart: true,
        textareaInOverlay: false,
        autofocus: false,
    };
    return EditableLabel;
}(Component));
export { EditableLabel };
//# sourceMappingURL=EditableLabel.js.map